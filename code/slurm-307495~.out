@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
probing_case 도입


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ RUNNING SCRIPT: job_n_NoAug_py_plbart_syn.sh

Wed Mar 22 17:05:44 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 465.19.01    Driver Version: 465.19.01    CUDA Version: 11.3     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  On   | 00000000:A1:00.0 Off |                  N/A |
| 30%   30C    P8    25W / 350W |      1MiB / 24268MiB |      1%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2022 NVIDIA Corporation
Built on Wed_Jun__8_16:49:14_PDT_2022
Cuda compilation tools, release 11.7, V11.7.99
Build cuda_11.7.r11.7/compiler.31442593_0
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START TRAIN @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: uclanlp/plbart-python-en_XX
Model type: plbart
Experiment name: plbart_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
/home/ysnamgoong42/ws/XLCoST/code
03/22/2023 17:05:47 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='uclanlp/plbart-python-en_XX', dev_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.py', do_eval=True, do_lower_case=False, do_test=False, do_train=True, eval_batch_size=16, eval_steps=2500, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path=None, local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='uclanlp/plbart-python-en_XX', model_type='plbart', no_cuda=False, num_train_epochs=10.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename=None, tokenizer_name='uclanlp/plbart-python-en_XX', train_batch_size=16, train_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.py', train_steps=5000, warmup_steps=0, weight_decay=0.0)
03/22/2023 17:05:48 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 17:06:02 - INFO - __main__ -   *** Example ***
03/22/2023 17:06:02 - INFO - __main__ -   idx: 0
03/22/2023 17:06:02 - INFO - __main__ -   source_tokens: ['<s>', '▁Maximum', '▁Prefix', '▁Sum', '▁possible', '▁by', '▁merging', '▁two', '▁given', '▁arrays', '▁|', '▁Python', '3', '▁implementation', '▁of', '▁the', '▁above', '▁approach', '▁;', '▁Store', 's', '▁the', '▁maximum', '▁prefix', '▁sum', '▁of', '▁the', '▁array', '▁A', '▁[', '▁]', '▁;', '▁Tra', 'verse', '▁the', '▁array', '▁A', '▁[', '▁]', '▁;', '▁Store', 's', '▁the', '▁maximum', '▁prefix', '▁sum', '▁of', '▁the', '▁array', '▁B', '▁[', '▁]', '▁;', '▁Tra', 'verse', '▁the', '▁array', '▁B', '▁[', '▁]', '▁;', '▁Driver', '▁code', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   source_ids: 0 21624 21138 9037 1678 389 20977 1149 2511 3868 678 1123 33502 3057 153 57 1817 2803 43 7746 33442 57 5452 2028 1942 153 57 596 150 91 99 43 3571 2314 57 596 150 91 99 43 7746 33442 57 5452 2028 1942 153 57 596 245 91 99 43 3571 2314 57 596 245 91 99 43 9193 344 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   target_tokens: ['<s>', '▁def', '▁max', 'Pres', 'um', '▁(', '▁a', '▁,', '▁b', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁X', '▁=', '▁max', '▁(', '▁a', '▁[', '▁0', '▁]', '▁,', '▁0', '▁)', '▁NEW', '_', 'LINE', '▁for', '▁i', '▁in', '▁range', '▁(', '▁1', '▁,', '▁len', '▁(', '▁a', '▁)', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁a', '▁[', '▁i', '▁]', '▁+=', '▁a', '▁[', '▁i', '▁-', '▁1', '▁]', '▁NEW', '_', 'LINE', '▁X', '▁=', '▁max', '▁(', '▁X', '▁,', '▁a', '▁[', '▁i', '▁]', '▁)', '▁NEW', '_', 'LINE', '▁DEDENT', '▁Y', '▁=', '▁max', '▁(', '▁b', '▁[', '▁0', '▁]', '▁,', '▁0', '▁)', '▁NEW', '_', 'LINE', '▁for', '▁i', '▁in', '▁range', '▁(', '▁1', '▁,', '▁len', '▁(', '▁b', '▁)', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁b', '▁[', '▁i', '▁]', '▁+=', '▁b', '▁[', '▁i', '▁-', '▁1', '▁]', '▁NEW', '_', 'LINE', '▁Y', '▁=', '▁max', '▁(', '▁Y', '▁,', '▁b', '▁[', '▁i', '▁]', '▁)', '▁NEW', '_', 'LINE', '▁DEDENT', '▁return', '▁X', '▁+', '▁Y', '▁NEW', '_', 'LINE', '▁DEDENT', '▁A', '▁=', '▁[', '▁2', '▁,', '▁-', '▁1', '▁,', '▁4', '▁,', '▁-', '▁5', '▁]', '▁NEW', '_', 'LINE', '▁B', '▁=', '▁[', '▁4', '▁,', '▁-', '▁3', '▁,', '▁12', '▁,', '▁4', '▁,', '▁-', '▁3', '▁]', '▁NEW', '_', 'LINE', '▁print', '▁(', '▁max', 'Pres', 'um', '▁(', '▁A', '▁,', '▁B', '▁)', '▁)', '▁NEW', '_', 'LINE', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   target_ids: 0 134 889 11762 137 5 14 16 56 6 54 21 33456 19 79 764 24 889 5 14 91 142 99 16 142 6 21 33456 19 126 25 55 1369 5 124 16 448 5 14 6 6 54 21 33456 19 79 14 91 25 99 939 14 91 25 158 124 99 21 33456 19 764 24 889 5 764 16 14 91 25 99 6 21 33456 19 80 460 24 889 5 56 91 142 99 16 142 6 21 33456 19 126 25 55 1369 5 124 16 448 5 56 6 6 54 21 33456 19 79 56 91 25 99 939 56 91 25 158 124 99 21 33456 19 460 24 889 5 460 16 56 91 25 99 6 21 33456 19 80 111 764 163 460 21 33456 19 80 150 24 91 217 16 158 124 16 508 16 158 581 99 21 33456 19 245 24 91 508 16 158 363 16 1497 16 508 16 158 363 99 21 33456 19 597 5 889 11762 137 5 150 16 245 6 6 21 33456 19 2 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   *** Example ***
03/22/2023 17:06:02 - INFO - __main__ -   idx: 1
03/22/2023 17:06:02 - INFO - __main__ -   source_tokens: ['<s>', '▁Check', '▁if', '▁a', '▁number', '▁can', '▁be', '▁represented', '▁as', '▁sum', '▁of', '▁two', '▁positive', '▁perfect', '▁cub', 'es', '▁|', '▁Python', '3', '▁program', '▁for', '▁the', '▁above', '▁approach', '▁;', '▁Function', '▁to', '▁check', '▁if', '▁N', '▁can', '▁be', '▁represented', '▁as', '▁sum', '▁of', '▁two', '▁perfect', '▁cub', 'es', '▁or', '▁not', '▁;', '▁If', '▁it', '▁is', '▁same', '▁return', '▁true', '▁;', '▁;', '▁If', '▁the', '▁curr', '▁smaller', '▁than', '▁n', '▁increment', '▁the', '▁lo', '▁;', '▁If', '▁the', '▁curr', '▁is', '▁greater', '▁than', '▁curr', '▁decrement', '▁the', '▁hi', '▁;', '▁Driver', '▁Code', '▁;', '▁Function', '▁call', '▁to', '▁check', '▁if', '▁N', '▁can', '▁be', '▁represented', '▁as', '▁sum', '▁of', '▁two', '▁perfect', '▁cub', 'es', '▁or', '▁not', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   source_ids: 0 2960 105 14 1019 252 229 13183 268 1942 153 1149 7397 5200 18010 29 678 1123 33502 1455 126 57 1817 2803 43 3839 71 553 105 171 252 229 13183 268 1942 153 1149 5200 18010 29 255 188 43 708 141 96 845 111 590 43 43 708 57 5328 8149 1433 42 4402 57 244 43 708 57 5328 96 6635 1433 5328 16053 57 8039 43 9193 2874 43 3839 549 71 553 105 171 252 229 13183 268 1942 153 1149 5200 18010 29 255 188 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   target_tokens: ['<s>', '▁import', '▁math', '▁NEW', '_', 'LINE', '▁def', '▁sum', 'Of', 'Two', 'C', 'ub', 'es', '▁(', '▁n', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁lo', '▁=', '▁1', '▁NEW', '_', 'LINE', '▁hi', '▁=', '▁round', '▁(', '▁math', '▁.', '▁pow', '▁(', '▁n', '▁,', '▁1', '▁/', '▁3', '▁)', '▁)', '▁NEW', '_', 'LINE', '▁while', '▁(', '▁lo', '▁<=', '▁hi', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁curr', '▁=', '▁(', '▁lo', '▁*', '▁lo', '▁*', '▁lo', '▁+', '▁hi', '▁*', '▁hi', '▁*', '▁hi', '▁)', '▁NEW', '_', 'LINE', '▁if', '▁(', '▁curr', '▁==', '▁n', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁return', '▁True', '▁NEW', '_', 'LINE', '▁DEDENT', '▁if', '▁(', '▁curr', '▁<', '▁n', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁lo', '▁+=', '▁1', '▁NEW', '_', 'LINE', '▁DEDENT', '▁else', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁hi', '▁-=', '▁1', '▁NEW', '_', 'LINE', '▁DEDENT', '▁DEDENT', '▁return', '▁False', '▁NEW', '_', 'LINE', '▁DEDENT', '▁N', '▁=', '▁28', '▁NEW', '_', 'LINE', '▁if', '▁(', '▁sum', 'Of', 'Two', 'C', 'ub', 'es', '▁(', '▁N', '▁)', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁print', '▁(', '▁"', '▁True', '▁"', '▁)', '▁NEW', '_', 'LINE', '▁DEDENT', '▁else', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁print', '▁(', '▁"', '▁False', '▁"', '▁)', '▁NEW', '_', 'LINE', '▁DEDENT', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   target_ids: 0 662 3649 21 33456 19 134 1942 990 6750 33481 120 29 5 42 6 54 21 33456 19 79 244 24 124 21 33456 19 8039 24 4339 5 3649 9 8940 5 42 16 124 194 363 6 6 21 33456 19 927 5 244 2192 8039 6 54 21 33456 19 79 5328 24 5 244 294 244 294 244 163 8039 294 8039 294 8039 6 21 33456 19 105 5 5328 258 42 6 54 21 33456 19 79 111 489 21 33456 19 80 105 5 5328 128 42 6 54 21 33456 19 79 244 939 124 21 33456 19 80 345 54 21 33456 19 79 8039 4691 124 21 33456 19 80 80 111 611 21 33456 19 80 171 24 7830 21 33456 19 105 5 1942 990 6750 33481 120 29 5 171 6 6 54 21 33456 19 79 597 5 40 489 40 6 21 33456 19 80 345 54 21 33456 19 79 597 5 40 611 40 6 21 33456 19 80 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   *** Example ***
03/22/2023 17:06:02 - INFO - __main__ -   idx: 2
03/22/2023 17:06:02 - INFO - __main__ -   source_tokens: ['<s>', '▁Generate', '▁an', '▁N', '▁|', '▁Python', '3', '▁program', '▁for', '▁the', '▁above', '▁approach', '▁;', '▁Function', '▁to', '▁generate', '▁all', '▁prime', '▁numbers', '▁upto', '▁10', '▁^', '▁6', '▁;', '▁Initialize', '▁s', 'ieve', '▁[', '▁]', '▁as', '▁1', '▁;', '▁Iterate', '▁over', '▁the', '▁range', '▁[', '▁2', '▁,', '▁N', '▁]', '▁;', '▁If', '▁current', '▁element', '▁is', '▁non', '▁-', '▁prime', '▁;', '▁Make', '▁all', '▁multiples', '▁of', '▁i', '▁as', '▁0', '▁;', '▁Function', '▁to', '▁construct', '▁an', '▁array', '▁A', '▁[', '▁]', '▁satisf', 'ying', '▁the', '▁given', '▁conditions', '▁;', '▁Store', 's', '▁the', '▁result', 'ant', '▁array', '▁;', '▁Store', 's', '▁all', '▁prime', '▁numbers', '▁;', '▁S', 'ieve', '▁of', '▁E', 'ra', 'st', 'ost', 'hen', 'es', '▁;', '▁Append', '▁the', '▁integer', '▁i', '▁if', '▁it', '▁is', '▁a', '▁prime', '▁;', '▁Ind', 'icates', '▁current', '▁position', '▁in', '▁list', '▁of', '▁prime', '▁numbers', '▁;', '▁Tra', 'verse', '▁the', '▁array', '▁arr', '▁[', '▁]', '▁;', '▁If', '▁already', '▁filled', '▁with', '▁another', '▁prime', '▁number', '▁;', '▁If', '▁A', '▁[', '▁i', '▁]', '▁is', '▁not', '▁filled', '▁but', '▁A', '▁[', '▁ind', '▁]', '▁is', '▁filled', '▁;', '▁Store', '▁A', '▁[', '▁i', '▁]', '▁=', '▁A', '▁[', '▁ind', '▁]', '▁;', '▁If', '▁none', '▁of', '▁them', '▁were', '▁filled', '▁;', '▁To', '▁make', '▁sure', '▁A', '▁[', '▁i', '▁]', '▁does', '▁not', '▁affect', '▁other', '▁values', '▁,', '▁store', '▁next', '▁prime', '▁number', '▁;', '▁Print', '▁the', '▁result', 'ant', '▁array', '▁;', '▁Driver', '▁Code', '▁;', '▁Function', '▁Call', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   source_ids: 0 11511 197 171 678 1123 33502 1455 126 57 1817 2803 43 3839 71 2232 515 6674 2749 24788 837 2495 864 43 20739 11 2019 91 99 268 124 43 21333 1340 57 1369 91 217 16 171 99 43 708 759 660 96 2178 158 6674 43 5656 515 29713 153 25 268 142 43 3839 71 4704 197 596 150 91 99 14302 10168 57 2511 6620 43 7746 33442 57 372 306 596 43 7746 33442 515 6674 2749 43 90 2019 153 315 145 48 371 29645 29 43 11266 57 3398 25 105 141 96 14 6674 43 7884 13205 759 1444 55 410 153 6674 2749 43 3571 2314 57 596 3454 91 99 43 708 1845 8566 215 1525 6674 1019 43 708 150 91 25 99 96 188 8566 321 150 91 506 99 96 8566 43 7746 150 91 25 99 24 150 91 506 99 43 708 3588 153 1158 3384 8566 43 1456 797 1619 150 91 25 99 657 188 8668 592 752 16 1422 919 6674 1019 43 4865 57 372 306 596 43 9193 2874 43 3839 5244 2 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   target_tokens: ['<s>', '▁s', 'ieve', '▁=', '▁[', '▁1', '▁]', '▁*', '▁(', '▁1000000', '▁+', '▁1', '▁)', '▁NEW', '_', 'LINE', '▁def', '▁s', 'ieve', 'Of', 'Pr', 'imes', '▁(', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁global', '▁s', 'ieve', '▁NEW', '_', 'LINE', '▁N', '▁=', '▁1000000', '▁NEW', '_', 'LINE', '▁for', '▁i', '▁in', '▁range', '▁(', '▁2', '▁,', '▁N', '▁+', '▁1', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁if', '▁i', '▁*', '▁i', '▁>', '▁N', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁break', '▁NEW', '_', 'LINE', '▁DEDENT', '▁if', '▁(', '▁s', 'ieve', '▁[', '▁i', '▁]', '▁==', '▁0', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁continue', '▁NEW', '_', 'LINE', '▁DEDENT', '▁for', '▁j', '▁in', '▁range', '▁(', '▁i', '▁*', '▁i', '▁,', '▁N', '▁+', '▁1', '▁,', '▁i', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁s', 'ieve', '▁[', '▁j', '▁]', '▁=', '▁0', '▁NEW', '_', 'LINE', '▁DEDENT', '▁DEDENT', '▁DEDENT', '▁def', '▁getArray', '▁(', '▁arr', '▁,', '▁N', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁global', '▁s', 'ieve', '▁NEW', '_', 'LINE', '▁A', '▁=', '▁[', '▁0', '▁]', '▁*', '▁N', '▁NEW', '_', 'LINE', '▁v', '▁=', '▁[', '▁]', '▁NEW', '_', 'LINE', '▁s', 'ieve', 'Of', 'Pr', 'imes', '▁(', '▁)', '▁NEW', '_', 'LINE', '▁for', '▁i', '▁in', '▁range', '▁(', '▁2', '▁,', '▁int', '▁(', '▁1', 'e', '5', '▁)', '▁+', '▁1', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁if', '▁(', '▁s', 'ieve', '▁[', '▁i', '▁]', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   target_ids: 0 11 2019 24 91 124 99 294 5 14533 163 124 6 21 33456 19 134 11 2019 990 3082 4754 5 6 54 21 33456 19 79 2095 11 2019 21 33456 19 171 24 14533 21 33456 19 126 25 55 1369 5 217 16 171 163 124 6 54 21 33456 19 79 105 25 294 25 202 171 54 21 33456 19 79 1117 21 33456 19 80 105 5 11 2019 91 25 99 258 142 6 54 21 33456 19 79 2049 21 33456 19 80 126 191 55 1369 5 25 294 25 16 171 163 124 16 25 6 54 21 33456 19 79 11 2019 91 191 99 24 142 21 33456 19 80 80 80 134 21975 5 3454 16 171 6 54 21 33456 19 79 2095 11 2019 21 33456 19 150 24 91 142 99 294 171 21 33456 19 81 24 91 99 21 33456 19 11 2019 990 3082 4754 5 6 21 33456 19 126 25 55 1369 5 217 16 219 5 124 33439 33509 6 163 124 6 54 21 33456 19 79 105 5 11 2019 91 25 99 2
03/22/2023 17:06:02 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   *** Example ***
03/22/2023 17:06:02 - INFO - __main__ -   idx: 3
03/22/2023 17:06:02 - INFO - __main__ -   source_tokens: ['<s>', '▁N', 'th', '▁natural', '▁number', '▁after', '▁removing', '▁all', '▁numbers', '▁consisting', '▁of', '▁the', '▁digit', '▁9', '▁|', '▁Function', '▁to', '▁find', '▁N', 'th', '▁number', '▁in', '▁base', '▁9', '▁;', '▁Store', 's', '▁the', '▁N', 'th', '▁number', '▁;', '▁Iterate', '▁while', '▁N', '▁is', '▁greater', '▁than', '▁0', '▁;', '▁Update', '▁result', '▁;', '▁Div', 'ide', '▁N', '▁by', '▁9', '▁;', '▁Multip', 'ly', '▁p', '▁by', '▁10', '▁;', '▁Return', '▁result', '▁;', '▁Driver', '▁Code', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   source_ids: 0 171 155 12710 1019 1081 6838 515 2749 24601 153 57 8082 1336 678 3839 71 694 171 155 1019 55 1314 1336 43 7746 33442 57 171 155 1019 43 21333 927 171 96 6635 1433 142 43 4046 372 43 13375 401 171 389 1336 43 22476 185 31 389 837 43 6379 372 43 9193 2874 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   target_tokens: ['<s>', '▁def', '▁find', 'N', 'th', 'Number', '▁(', '▁N', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁result', '▁=', '▁0', '▁NEW', '_', 'LINE', '▁p', '▁=', '▁1', '▁NEW', '_', 'LINE', '▁while', '▁(', '▁N', '▁>', '▁0', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁result', '▁+=', '▁(', '▁p', '▁*', '▁(', '▁N', '▁%', '▁9', '▁)', '▁)', '▁NEW', '_', 'LINE', '▁N', '▁=', '▁N', '▁//', '▁9', '▁NEW', '_', 'LINE', '▁p', '▁=', '▁p', '▁*', '▁10', '▁NEW', '_', 'LINE', '▁DEDENT', '▁return', '▁result', '▁NEW', '_', 'LINE', '▁DEDENT', '▁if', '▁__', 'name', '__', '▁==', "▁'", '▁_', '▁_', '▁main', '▁_', '▁_', "▁'", '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁N', '▁=', '▁9', '▁NEW', '_', 'LINE', '▁print', '▁(', '▁find', 'N', 'th', 'Number', '▁(', '▁N', '▁)', '▁)', '▁NEW', '_', 'LINE', '▁DEDENT', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   target_ids: 0 134 694 33452 155 1953 5 171 6 54 21 33456 19 79 372 24 142 21 33456 19 31 24 124 21 33456 19 927 5 171 202 142 6 54 21 33456 19 79 372 939 5 31 294 5 171 247 1336 6 6 21 33456 19 171 24 171 685 1336 21 33456 19 31 24 31 294 837 21 33456 19 80 111 372 21 33456 19 80 105 429 308 387 258 35 92 92 1315 92 92 35 54 21 33456 19 79 171 24 1336 21 33456 19 597 5 694 33452 155 1953 5 171 6 6 21 33456 19 80 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   *** Example ***
03/22/2023 17:06:02 - INFO - __main__ -   idx: 4
03/22/2023 17:06:02 - INFO - __main__ -   source_tokens: ['<s>', '▁Check', '▁if', '▁an', '▁integer', '▁is', '▁rotation', '▁of', '▁another', '▁given', '▁integer', '▁|', '▁Python', '3', '▁implementation', '▁of', '▁the', '▁approach', '▁;', '▁Function', '▁to', '▁check', '▁if', '▁the', '▁integer', '▁A', '▁is', '▁a', '▁rotation', '▁of', '▁the', '▁integer', '▁B', '▁;', '▁Store', 's', '▁the', '▁count', '▁of', '▁digits', '▁in', '▁A', '▁;', '▁Store', 's', '▁the', '▁count', '▁of', '▁digits', '▁in', '▁B', '▁;', '▁If', '▁dig', '1', '▁not', '▁equal', '▁to', '▁dig', '2', '▁;', '▁Store', 's', '▁position', '▁of', '▁first', '▁digit', '▁;', '▁Store', 's', '▁the', '▁first', '▁digit', '▁;', '▁Rot', 'ate', '▁the', '▁digits', '▁of', '▁the', '▁integer', '▁;', '▁If', '▁A', '▁is', '▁equal', '▁to', '▁B', '▁;', '▁If', '▁A', '▁is', '▁equal', '▁to', '▁the', '▁initial', '▁value', '▁of', '▁integer', '▁A', '▁;', '▁Driver', '▁code', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   source_ids: 0 2960 105 197 3398 96 8899 153 1525 2511 3398 678 1123 33502 3057 153 57 2803 43 3839 71 553 105 57 3398 150 96 14 8899 153 57 3398 245 43 7746 33442 57 945 153 6104 55 150 43 7746 33442 57 945 153 6104 55 245 43 708 3138 33485 188 868 71 3138 33496 43 7746 33442 1444 153 723 8082 43 7746 33442 57 723 8082 43 17724 94 57 6104 153 57 3398 43 708 150 96 868 71 245 43 708 150 96 868 71 57 1688 276 153 3398 150 43 9193 344 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:06:02 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:06:02 - INFO - __main__ -   target_tokens: ['<s>', '▁import', '▁math', '▁NEW', '_', 'LINE', '▁def', '▁check', '▁(', '▁A', '▁,', '▁B', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁if', '▁(', '▁A', '▁==', '▁B', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁return', '▁1', '▁NEW', '_', 'LINE', '▁DEDENT', '▁dig', '1', '▁=', '▁math', '▁.', '▁floor', '▁(', '▁math', '▁.', '▁log', '10', '▁(', '▁A', '▁)', '▁+', '▁1', '▁)', '▁NEW', '_', 'LINE', '▁dig', '2', '▁=', '▁math', '▁.', '▁floor', '▁(', '▁math', '▁.', '▁log', '10', '▁(', '▁B', '▁)', '▁+', '▁1', '▁)', '▁NEW', '_', 'LINE', '▁if', '▁(', '▁dig', '1', '▁!=', '▁dig', '2', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁return', '▁0', '▁NEW', '_', 'LINE', '▁DEDENT', '▁temp', '▁=', '▁A', '▁NEW', '_', 'LINE', '▁while', '▁(', '▁True', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁power', '▁=', '▁pow', '▁(', '▁10', '▁,', '▁dig', '1', '▁-', '▁1', '▁)', '▁NEW', '_', 'LINE', '▁first', 'digit', '▁=', '▁A', '▁//', '▁power', '▁NEW', '_', 'LINE', '▁A', '▁=', '▁A', '▁-', '▁first', 'digit', '▁*', '▁power', '▁NEW', '_', 'LINE', '▁A', '▁=', '▁A', '▁*', '▁10', '▁+', '▁first', 'digit', '▁NEW', '_', 'LINE', '▁if', '▁(', '▁A', '▁==', '▁B', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁return', '▁1', '▁NEW', '_', 'LINE', '▁DEDENT', '▁if', '▁(', '▁A', '▁==', '▁temp', '▁)', '▁:', '▁NEW', '_', 'LINE', '▁INDENT', '▁return', '▁0', '▁NEW', '_', 'LINE', '▁DEDENT', '▁DEDENT', '▁DEDENT', '▁A', '▁,', '▁B', '▁=', '▁9', '67', '▁,', '▁6', '79', '</s>']
03/22/2023 17:06:02 - INFO - __main__ -   target_ids: 0 662 3649 21 33456 19 134 553 5 150 16 245 6 54 21 33456 19 79 105 5 150 258 245 6 54 21 33456 19 79 111 124 21 33456 19 80 3138 33485 24 3649 9 11024 5 3649 9 504 1134 5 150 6 163 124 6 21 33456 19 3138 33496 24 3649 9 11024 5 3649 9 504 1134 5 245 6 163 124 6 21 33456 19 105 5 3138 33485 472 3138 33496 6 54 21 33456 19 79 111 142 21 33456 19 80 2050 24 150 21 33456 19 927 5 489 6 54 21 33456 19 79 6074 24 8940 5 837 16 3138 33485 158 124 6 21 33456 19 723 11213 24 150 685 6074 21 33456 19 150 24 150 158 723 11213 294 6074 21 33456 19 150 24 150 294 837 163 723 11213 21 33456 19 105 5 150 258 245 6 54 21 33456 19 79 111 124 21 33456 19 80 105 5 150 258 2050 6 54 21 33456 19 79 111 142 21 33456 19 80 80 80 150 16 245 24 1336 6127 16 864 4303 2
03/22/2023 17:06:02 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
/home/ysnamgoong42/miniconda3/envs/xlcost/lib/python3.8/site-packages/transformers/optimization.py:306: FutureWarning: This implementation of AdamW is deprecated and will be removed in a future version. Use the PyTorch implementation torch.optim.AdamW instead, or set `no_deprecation_warning=True` to disable this warning
  warnings.warn(
03/22/2023 17:06:15 - INFO - __main__ -   ***** Running training *****
03/22/2023 17:06:15 - INFO - __main__ -     Num examples = 9263
03/22/2023 17:06:15 - INFO - __main__ -     Batch size = 16
03/22/2023 17:06:15 - INFO - __main__ -     Num epoch = 9
03/22/2023 17:06:40 - INFO - __main__ -     step 100 loss 2.41
03/22/2023 17:07:04 - INFO - __main__ -     step 200 loss 1.7431
03/22/2023 17:07:28 - INFO - __main__ -     step 300 loss 1.4833
03/22/2023 17:07:52 - INFO - __main__ -     step 400 loss 1.3258
03/22/2023 17:08:17 - INFO - __main__ -     step 500 loss 1.2277
03/22/2023 17:08:41 - INFO - __main__ -     step 600 loss 1.1532
03/22/2023 17:09:04 - INFO - __main__ -     step 700 loss 1.0954
03/22/2023 17:09:28 - INFO - __main__ -     step 800 loss 1.0466
03/22/2023 17:09:51 - INFO - __main__ -     step 900 loss 1.0073
03/22/2023 17:10:15 - INFO - __main__ -     step 1000 loss 0.9717
03/22/2023 17:10:39 - INFO - __main__ -     step 1100 loss 0.9431
03/22/2023 17:10:54 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:10:54 - INFO - __main__ -     Num examples = 472
03/22/2023 17:10:54 - INFO - __main__ -     Batch size = 16
03/22/2023 17:10:57 - INFO - __main__ -     eval_ppl = 1.84483
03/22/2023 17:10:57 - INFO - __main__ -     global_step = 1157
03/22/2023 17:10:57 - INFO - __main__ -     train_loss = 0.9278
03/22/2023 17:10:57 - INFO - __main__ -     ********************
03/22/2023 17:11:01 - INFO - __main__ -     Best ppl:1.84483
03/22/2023 17:11:01 - INFO - __main__ -     ********************
03/22/2023 17:12:45 - INFO - __main__ -     bleu-4 = 24.31 
03/22/2023 17:12:45 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:12:45 - INFO - __main__ -     ********************
03/22/2023 17:12:45 - INFO - __main__ -     Best bleu:24.31
03/22/2023 17:12:45 - INFO - __main__ -     ********************
03/22/2023 17:12:58 - INFO - __main__ -     step 1200 loss 0.6363
03/22/2023 17:13:22 - INFO - __main__ -     step 1300 loss 0.6234
03/22/2023 17:13:46 - INFO - __main__ -     step 1400 loss 0.6106
03/22/2023 17:14:10 - INFO - __main__ -     step 1500 loss 0.6001
03/22/2023 17:14:34 - INFO - __main__ -     step 1600 loss 0.5928
03/22/2023 17:14:58 - INFO - __main__ -     step 1700 loss 0.586
03/22/2023 17:15:21 - INFO - __main__ -     step 1800 loss 0.5793
03/22/2023 17:15:44 - INFO - __main__ -     step 1900 loss 0.5727
03/22/2023 17:16:08 - INFO - __main__ -     step 2000 loss 0.5669
03/22/2023 17:16:31 - INFO - __main__ -     step 2100 loss 0.5601
03/22/2023 17:16:54 - INFO - __main__ -     step 2200 loss 0.554
03/22/2023 17:17:17 - INFO - __main__ -     step 2300 loss 0.5484
03/22/2023 17:17:21 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:17:21 - INFO - __main__ -     Num examples = 472
03/22/2023 17:17:21 - INFO - __main__ -     Batch size = 16
03/22/2023 17:17:23 - INFO - __main__ -     eval_ppl = 1.7482
03/22/2023 17:17:23 - INFO - __main__ -     global_step = 2314
03/22/2023 17:17:23 - INFO - __main__ -     train_loss = 0.5479
03/22/2023 17:17:23 - INFO - __main__ -     ********************
03/22/2023 17:17:28 - INFO - __main__ -     Best ppl:1.7482
03/22/2023 17:17:28 - INFO - __main__ -     ********************
03/22/2023 17:19:13 - INFO - __main__ -     bleu-4 = 27.69 
03/22/2023 17:19:13 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:19:13 - INFO - __main__ -     ********************
03/22/2023 17:19:13 - INFO - __main__ -     Best bleu:27.69
03/22/2023 17:19:13 - INFO - __main__ -     ********************
03/22/2023 17:19:39 - INFO - __main__ -     step 2400 loss 0.487
03/22/2023 17:20:04 - INFO - __main__ -     step 2500 loss 0.4775
03/22/2023 17:20:28 - INFO - __main__ -     step 2600 loss 0.4755
03/22/2023 17:20:52 - INFO - __main__ -     step 2700 loss 0.4687
03/22/2023 17:21:15 - INFO - __main__ -     step 2800 loss 0.4646
03/22/2023 17:21:38 - INFO - __main__ -     step 2900 loss 0.4612
03/22/2023 17:22:01 - INFO - __main__ -     step 3000 loss 0.4585
03/22/2023 17:22:22 - INFO - __main__ -     step 3100 loss 0.454
03/22/2023 17:22:44 - INFO - __main__ -     step 3200 loss 0.4514
03/22/2023 17:23:07 - INFO - __main__ -     step 3300 loss 0.4468
03/22/2023 17:23:31 - INFO - __main__ -     step 3400 loss 0.4437
03/22/2023 17:23:47 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:23:47 - INFO - __main__ -     Num examples = 472
03/22/2023 17:23:47 - INFO - __main__ -     Batch size = 16
03/22/2023 17:23:50 - INFO - __main__ -     eval_ppl = 1.7313
03/22/2023 17:23:50 - INFO - __main__ -     global_step = 3471
03/22/2023 17:23:50 - INFO - __main__ -     train_loss = 0.4412
03/22/2023 17:23:50 - INFO - __main__ -     ********************
03/22/2023 17:23:55 - INFO - __main__ -     Best ppl:1.7313
03/22/2023 17:23:55 - INFO - __main__ -     ********************
03/22/2023 17:25:42 - INFO - __main__ -     bleu-4 = 27.76 
03/22/2023 17:25:42 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:25:42 - INFO - __main__ -     ********************
03/22/2023 17:25:42 - INFO - __main__ -     Best bleu:27.76
03/22/2023 17:25:42 - INFO - __main__ -     ********************
03/22/2023 17:25:54 - INFO - __main__ -     step 3500 loss 0.4084
03/22/2023 17:26:18 - INFO - __main__ -     step 3600 loss 0.4045
03/22/2023 17:26:41 - INFO - __main__ -     step 3700 loss 0.3997
03/22/2023 17:27:04 - INFO - __main__ -     step 3800 loss 0.3962
03/22/2023 17:27:27 - INFO - __main__ -     step 3900 loss 0.3916
03/22/2023 17:27:51 - INFO - __main__ -     step 4000 loss 0.39
03/22/2023 17:28:14 - INFO - __main__ -     step 4100 loss 0.3874
03/22/2023 17:28:38 - INFO - __main__ -     step 4200 loss 0.3853
03/22/2023 17:29:01 - INFO - __main__ -     step 4300 loss 0.383
03/22/2023 17:29:24 - INFO - __main__ -     step 4400 loss 0.3803
03/22/2023 17:29:47 - INFO - __main__ -     step 4500 loss 0.3776
03/22/2023 17:30:11 - INFO - __main__ -     step 4600 loss 0.3757
03/22/2023 17:30:18 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:30:18 - INFO - __main__ -     Num examples = 472
03/22/2023 17:30:18 - INFO - __main__ -     Batch size = 16
03/22/2023 17:30:21 - INFO - __main__ -     eval_ppl = 1.73262
03/22/2023 17:30:21 - INFO - __main__ -     global_step = 4628
03/22/2023 17:30:21 - INFO - __main__ -     train_loss = 0.3751
03/22/2023 17:30:21 - INFO - __main__ -     ********************
03/22/2023 17:32:06 - INFO - __main__ -     bleu-4 = 28.29 
03/22/2023 17:32:06 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:32:06 - INFO - __main__ -     ********************
03/22/2023 17:32:06 - INFO - __main__ -     Best bleu:28.29
03/22/2023 17:32:06 - INFO - __main__ -     ********************
03/22/2023 17:32:27 - INFO - __main__ -     step 4700 loss 0.3571
03/22/2023 17:32:50 - INFO - __main__ -     step 4800 loss 0.3515
03/22/2023 17:33:13 - INFO - __main__ -     step 4900 loss 0.3501
03/22/2023 17:33:36 - INFO - __main__ -     step 5000 loss 0.3466
03/22/2023 17:33:59 - INFO - __main__ -     step 5100 loss 0.3442
03/22/2023 17:34:21 - INFO - __main__ -     step 5200 loss 0.3428
03/22/2023 17:34:43 - INFO - __main__ -     step 5300 loss 0.3423
03/22/2023 17:35:06 - INFO - __main__ -     step 5400 loss 0.3404
03/22/2023 17:35:28 - INFO - __main__ -     step 5500 loss 0.3396
03/22/2023 17:35:50 - INFO - __main__ -     step 5600 loss 0.3378
03/22/2023 17:36:13 - INFO - __main__ -     step 5700 loss 0.3368
03/22/2023 17:36:31 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:36:31 - INFO - __main__ -     Num examples = 472
03/22/2023 17:36:31 - INFO - __main__ -     Batch size = 16
03/22/2023 17:36:34 - INFO - __main__ -     eval_ppl = 1.73278
03/22/2023 17:36:34 - INFO - __main__ -     global_step = 5785
03/22/2023 17:36:34 - INFO - __main__ -     train_loss = 0.336
03/22/2023 17:36:34 - INFO - __main__ -     ********************
03/22/2023 17:38:17 - INFO - __main__ -     bleu-4 = 28.55 
03/22/2023 17:38:17 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:38:17 - INFO - __main__ -     ********************
03/22/2023 17:38:17 - INFO - __main__ -     Best bleu:28.55
03/22/2023 17:38:17 - INFO - __main__ -     ********************
03/22/2023 17:38:29 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='uclanlp/plbart-python-en_XX', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='uclanlp/plbart-python-en_XX', model_type='plbart', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='uclanlp/plbart-python-en_XX', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 17:38:29 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 17:38:45 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 17:38:48 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:04<04:27,  4.86s/it]  4%|▎         | 2/56 [00:07<03:14,  3.60s/it]  5%|▌         | 3/56 [00:10<02:47,  3.16s/it]  7%|▋         | 4/56 [00:12<02:34,  2.97s/it]  9%|▉         | 5/56 [00:15<02:26,  2.88s/it] 11%|█         | 6/56 [00:18<02:20,  2.81s/it] 12%|█▎        | 7/56 [00:21<02:21,  2.88s/it] 14%|█▍        | 8/56 [00:24<02:19,  2.90s/it] 16%|█▌        | 9/56 [00:27<02:17,  2.93s/it] 18%|█▊        | 10/56 [00:30<02:15,  2.94s/it] 20%|█▉        | 11/56 [00:33<02:13,  2.97s/it] 21%|██▏       | 12/56 [00:36<02:10,  2.97s/it] 23%|██▎       | 13/56 [00:39<02:10,  3.04s/it] 25%|██▌       | 14/56 [00:42<02:12,  3.16s/it] 27%|██▋       | 15/56 [00:46<02:12,  3.24s/it] 29%|██▊       | 16/56 [00:49<02:10,  3.27s/it] 30%|███       | 17/56 [00:53<02:10,  3.35s/it] 32%|███▏      | 18/56 [00:56<02:07,  3.35s/it] 34%|███▍      | 19/56 [01:00<02:06,  3.43s/it] 36%|███▌      | 20/56 [01:03<02:05,  3.49s/it] 38%|███▊      | 21/56 [01:07<02:04,  3.57s/it] 39%|███▉      | 22/56 [01:11<02:01,  3.58s/it] 41%|████      | 23/56 [01:14<02:01,  3.67s/it] 43%|████▎     | 24/56 [01:18<01:59,  3.72s/it] 45%|████▍     | 25/56 [01:22<01:57,  3.79s/it] 46%|████▋     | 26/56 [01:27<01:59,  3.98s/it] 48%|████▊     | 27/56 [01:31<01:57,  4.06s/it] 50%|█████     | 28/56 [01:35<01:55,  4.11s/it] 52%|█████▏    | 29/56 [01:40<01:55,  4.27s/it] 54%|█████▎    | 30/56 [01:44<01:52,  4.32s/it] 55%|█████▌    | 31/56 [01:49<01:49,  4.38s/it] 57%|█████▋    | 32/56 [01:53<01:45,  4.39s/it] 59%|█████▉    | 33/56 [01:58<01:41,  4.40s/it] 61%|██████    | 34/56 [02:02<01:36,  4.40s/it] 62%|██████▎   | 35/56 [02:07<01:33,  4.47s/it] 64%|██████▍   | 36/56 [02:11<01:30,  4.52s/it] 66%|██████▌   | 37/56 [02:16<01:25,  4.50s/it] 68%|██████▊   | 38/56 [02:20<01:21,  4.54s/it] 70%|██████▉   | 39/56 [02:25<01:18,  4.60s/it] 71%|███████▏  | 40/56 [02:30<01:14,  4.66s/it] 73%|███████▎  | 41/56 [02:35<01:09,  4.65s/it] 75%|███████▌  | 42/56 [02:39<01:05,  4.68s/it] 77%|███████▋  | 43/56 [02:44<01:01,  4.77s/it] 79%|███████▊  | 44/56 [02:49<00:58,  4.85s/it] 80%|████████  | 45/56 [02:54<00:53,  4.91s/it] 82%|████████▏ | 46/56 [03:00<00:49,  4.98s/it] 84%|████████▍ | 47/56 [03:05<00:45,  5.02s/it] 86%|████████▌ | 48/56 [03:10<00:40,  5.07s/it] 88%|████████▊ | 49/56 [03:15<00:36,  5.24s/it] 89%|████████▉ | 50/56 [03:21<00:32,  5.48s/it] 91%|█████████ | 51/56 [03:27<00:27,  5.46s/it] 93%|█████████▎| 52/56 [03:32<00:22,  5.51s/it] 95%|█████████▍| 53/56 [03:38<00:16,  5.56s/it] 96%|█████████▋| 54/56 [03:44<00:11,  5.62s/it] 98%|█████████▊| 55/56 [03:50<00:05,  5.68s/it]100%|██████████| 56/56 [03:55<00:00,  5.51s/it]100%|██████████| 56/56 [03:55<00:00,  4.20s/it]
03/22/2023 17:42:45 - INFO - __main__ -     bleu-4 = 29.23 
03/22/2023 17:42:45 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:42:45 - INFO - __main__ -     ********************
tokenizer.decode(top_preds[0],: def findMinSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE mp [ arr [ j ] ] = mp . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT DEDENT minSum = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT minSum = min ( minSum , value ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMinSum ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def decToBinary ( arr , n ) : NEW_LINE INDENT binary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT binary += arr [ i ] NEW_LINE DEDENT return binary NEW_LINE DEDENT def decToBinary ( arr , n ) : NEW_LINE INDENT binary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT binary += arr [ i ] NEW_LINE DEDENT return binary NEW_LINE DEDENT def concat ( a , b , n , k ) : NEW_LINE INDENT len1 = len ( a ) NEW_LINE len2 = len ( b ) NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT a [ i ] = decToBinary ( a [ i ] , n ) NEW_LINE DEDENT for i in range ( len2 ) : NEW_LINE INDENT b [ i ] = decToBinary ( b [ i ] , n
tokenizer.decode(top_preds[0],: from bisect import bisect_left , bisect_right NEW_LINE def convert ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == '0' ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( n [ i ] ) NEW_LINE DEDENT DEDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countB ( A , C ) : NEW_LINE INDENT n = len ( A ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( int ( A [ i ] ) ) NEW_LINE DEDENT return len ( v ) NEW_LINE DEDENT def countCandB ( A , C ) : NEW_LINE INDENT n = len ( A ) NEW_LINE v = convert ( A
tokenizer.decode(top_preds[0],: def isvalid ( time ) : NEW_LINE INDENT if ( time <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( time <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( time <= 24 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isvalid ( time ) NEW_LINE DEDENT def isvalid ( time ) : NEW_LINE INDENT return ( time >= 24 ) NEW_LINE DEDENT def findMaxTime ( L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 24 , R + 1 ) : NEW_LINE INDENT if ( isvalid ( i ) ) : NEW_LINE INDENT res = res + i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findMaxTime ( L , R ) : NEW_LINE INDENT if ( L > R ) : NEW
tokenizer.decode(top_preds[0],: import math NEW_LINE def max intersection ( r1 , r2 , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT r1 = math . sqrt ( math . pow ( x1 , 2 ) + math . pow ( y1 , 2 ) + math . pow ( x2 , 2 ) ) NEW_LINE r2 = math . sqrt ( math . pow ( y2 , 2 ) + math . pow ( x1 , 2 ) ) NEW_LINE return max ( r1 , r2 ) NEW_LINE DEDENT r1 = 1 NEW_LINE r2 = 1 NEW_LINE x1 = 2 NEW_LINE y1 = 3 NEW_LINE x2 = 4 NEW_LINE y2 = 5 NEW_LINE print ( max intersection ( r1 , r2 , x1 , y1 , x2 , y2 ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def is undulating ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 19 NEW_LINE if ( is undulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def MSBNum ( n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) + 1 NEW_LINE return ( n & ( k - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( MSBNum ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def leftRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] , arr [ i + d ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def rightRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] , arr [ i + d ] = arr [ i ] , arr [ i + d ] NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE d = 5 NEW_LINE leftRotate ( arr , n , d ) NEW_LINE
tokenizer.decode(top_preds[0],: def findMissing ( arr , n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] == arr [ mid + 1 ] ) : NEW_LINE INDENT high = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: MAX = 26 NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , i , j , len1 , len2 ) : NEW_LINE INDENT if ( i == len1 and j == len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp
tokenizer.decode(top_preds[0],: def findWays ( n ) : NEW_LINE INDENT fac1 = n - 1 NEW_LINE fac2 = n - 2 NEW_LINE if ( fac1 == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 1 ) : NEW_LINE INDENT print ( 3 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 1 ) : NEW_LINE INDENT print ( 4 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 2 ) : NEW_LINE INDENT print ( 5 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 3 ) : NEW_LINE INDENT print ( 6 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 2 ) : NEW_LINE INDENT print ( 7 ) NEW_LINE return NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def isComposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def kTrials ( n , d ) : NEW_LINE INDENT if ( n % d == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n > 4 ) : NEW_
tokenizer.decode(top_preds[0],: def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] = mp . get ( A [ j ] , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] = mp . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT DEDENT for i in mp : NEW_LINE INDENT for j in mp : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE
tokenizer.decode(top_preds[0],: from math import * NEW_LINE def area_of_ sector ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 2 NEW_LINE print ( area_of_ sector ( a , b ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def minimumSwaps ( N ) : NEW_LINE INDENT a = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if
tokenizer.decode(top_preds[0],: def findLIS ( arr , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range
tokenizer.decode(top_preds[0],: def seriesSum ( A ) : NEW_LINE INDENT return ( A * ( A + 1 ) ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 1 NEW_LINE print ( seriesSum ( A ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def sortArr ( a , b , n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE sortArr ( arr , 0 , len ( arr ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maxSquares ( n ) : NEW_LINE INDENT return n * ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( maxSquares ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: N = 3 NEW_LINE M = 3 NEW_LINE def countSets ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT ans += mat [ i ] [ j ] - mat [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 ,
tokenizer.decode(top_preds[0],: dp = [ [ 0 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE def pathCountDP ( m , n , k ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT dp [ m ] [ n ] = pathCountDP ( m - 1 , n , k ) + ( pathCountDP ( m - 1 , n - 1 , k ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
tokenizer.decode(top_preds[0],: def addTwoNumbers ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( carry == 0 ) : NEW_LINE INDENT x = x ^ y NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ x NEW_LINE carry = 1 NEW_LINE DEDENT DEDENT return x + y NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE y = 20 NEW_LINE print ( addTwoNumbers ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: Precompute ( ) : NEW_LINE INDENT prefixXOR = 0 NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT for i in range ( 1 , 100 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT return prefixXOR NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) )
tokenizer.decode(top_preds[0],: def reverseArray ( arr , s , e ) : NEW_LINE INDENT for i in range ( s , e + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def generateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateArray ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maximumABs ( A , B ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == B [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( A [ i ] == ' A ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' ) : NEW_LINE INDENT B [ i ] = 1 NEW_LINE DEDENT elif ( A [ i ] == ' A ' ) : NEW_LINE INDENT B [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( A [ i ] == ' A ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' )
tokenizer.decode(top_preds[0],: def longestSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE x = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE longestSubsequence ( arr , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countSubsets ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countSubsets ( arr , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairs ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( A , B , n , x , y ) : NEW_LINE INDENT if ( x < 0 or y < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] < B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE B = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( A ) NEW_LINE x = 2 NEW_LINE y = 2 NEW_LINE if ( isPossible ( A , B , n , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW
tokenizer.decode(top_preds[0],: def countMinOperations ( arr , N ) : NEW_LINE INDENT prefixSum = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT maximum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if ( prefixSum [ j ] == prefixSum [ i ] ) : NEW_LINE INDENT groupSum [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT groupSum [ j ] -= 1 NEW_LINE DEDENT DEDENT maximum = max ( maximum , groupSum [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr )
tokenizer.decode(top_preds[0],: def solve ( A , N ) : NEW_LINE INDENT shift = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT shift += 1 NEW_LINE DEDENT print ( shift ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE solve ( A , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from collections import defaultdict NEW_LINE def smallestString ( s ) : NEW_LINE INDENT initial_ frequencies = defaultdict ( lambda : 0 ) NEW_LINE processed = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT initial_ frequencies [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT processed [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( processed [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == len ( s ) - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( processed [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == len ( s )
tokenizer.decode(top_preds[0],: import sys NEW_LINE def check ( arr , i , j , sm1 , sm2 , sm3 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sm1 [ i ] != - 1 ) : NEW_LINE INDENT return sm1 [ i ] NEW_LINE DEDENT if ( sm2 [ j ] != - 1 ) : NEW_LINE INDENT sm2 [ j ] = sm1 [ j ] NEW_LINE DEDENT if ( sm3 [ i ] != - 1 ) : NEW_LINE INDENT sm3 [ j ] = sm2 [ j ] NEW_LINE DEDENT if ( sm1 [ i ] != - 1 ) : NEW_LINE INDENT return sm1 [ i ] NEW_LINE DEDENT if ( sm2 [ j ] != - 1 ) : NEW_LINE INDENT return sm2 [ j ] NEW_LINE DEDENT if ( sm3 [ i ] != - 1 ) : NEW
tokenizer.decode(top_preds[0],: def maxSubArraySum ( a , n , k ) : NEW_LINE INDENT maxSubArraySum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] != a [ n - 1 ] ) : NEW_LINE INDENT maxSubArraySum += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxSubArraySum = max ( maxSubArraySum , a [ i ] ) NEW_LINE DEDENT DEDENT return maxSubArraySum NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxSubArraySum ( a , n , k ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def palindromicString ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE st = set ( ) NEW_LINE for ch in S : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Hash [ i ] == 2 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT elif ( Hash [ i ] == 3 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] > 0 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT if ( Hash [ i ] > 0 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range (
tokenizer.decode(top_preds[0],: NO_OF_CHARS = 256 NEW_LINE def encrypt ( s , x ) : NEW_LINE INDENT x = x NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 0 ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: def count ( s ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( count ( s ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = r * r ; NEW_LINE return a ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 ; NEW_LINE print ( circlearea ( r ) ) ; NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def findSquares ( N ) : NEW_LINE INDENT block = [ 0 for i in range ( 8 ) ] NEW_LINE block [ 0 ] = 1 NEW_LINE block [ 1 ] = 1 NEW_LINE block [ 2 ] = 1 NEW_LINE for i in range ( 3 , N ) : NEW_LINE INDENT block [ i ] = block [ i - 1 ] + block [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( block [ i ] == 1 ) : NEW_LINE INDENT print ( block [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( block [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE findSquares ( N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def productOfPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product *= arr [ i ] * arr [ j ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productOfPairs ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 2 NEW_LINE isPossible ( x , y ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def checkPointIs inside rectangle ( point ) : NEW_LINE INDENT bottom_left = point [ 0 ] NEW_LINE top_right = point [ 1 ] NEW_LINE for i in range ( 2 , bottom_left + 1 ) : NEW_LINE INDENT bottom_right = point [ i ] NEW_LINE top_left = point [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , top_right + 1 ) : NEW_LINE INDENT bottom_left = point [ i ] NEW_LINE top_right = point [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , bottom_left + 1 ) : NEW_LINE INDENT for j in range ( 1 , top_right + 1 ) : NEW_LINE INDENT if ( i >= bottom_left and i <= top_right + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ ==
tokenizer.decode(top_preds[0],: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT elif ( K == 2 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( maxSum ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( sqrt ( n ) ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( sqrt ( n ) ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE
tokenizer.decode(top_preds[0],: mod = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 4 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 5 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 8 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 8 ) : NEW
tokenizer.decode(top_preds[0],: def updateQuery ( arr , n , queries ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _
tokenizer.decode(top_preds[0],: def arePermutation ( a1 , b1 , a2 , b2 , n1 , n2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 0 NEW_LINE mul2 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += a1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += a2 [ i ] NEW_LINE mul1 = mul2 NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT sum1 += a1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += a2 [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main
tokenizer.decode(top_preds[0],: def avg ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( avg ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( max_element ) : NEW_LINE INDENT if ( freq [ j ] == 0 ) : NEW_LINE INDENT pairs += 1 NEW_LINE DEDENT elif ( freq [ j ] > 1 ) : NEW_LINE INDENT pairs += 1 NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n
tokenizer.decode(top_preds[0],: def minOperations ( m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n > m ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + minOperations ( m , n // 2 ) ; NEW_LINE DEDENT return minOperations ( m , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 ; NEW_LINE n = 10 ; NEW_LINE print ( minOperations ( m , n ) ) ; NEW_
tokenizer.decode(top_preds[0],: from math import log10 , floor NEW_LINE def reverseDigits ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 19 NEW_LINE print ( reverseDigits ( num ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( len ( arr1 ) ) : NEW_LINE INDENT for j in range ( len ( arr2 ) ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * M NEW_LINE countTW = [ 0 ] * M NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( M
tokenizer.decode(top_preds[0],: def diagonals ( n ) : NEW_LINE INDENT diagonals = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT diagonals += i NEW_LINE DEDENT return diagonals NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( diagonals ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def kthSubStr ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( k > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT cnt = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE cnt [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += cnt [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] NEW_LINE cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range (
tokenizer.decode(top_preds[0],: def printArrangement ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( 12 , 24 ) : NEW_LINE INDENT format1 = arr1 [ i ] NEW_LINE format2 = arr2 [ i ] NEW_LINE if ( format1 < format2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def sort ( arr , n ) : NEW_LINE INDENT format1 = str ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT format2 = str ( arr [ i ] ) NEW_LINE if ( compare ( arr1 , arr2 ) ) : NEW_LINE
tokenizer.decode(top_preds[0],: def minDiff ( a , n ) : NEW_LINE INDENT min_diff = a [ 0 ] - a [ 1 ] NEW_LINE max_diff = a [ 1 ] - a [ 0 ] NEW_LINE return min_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minDiff ( a , n ) ) NEW_LINE DEDENT
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START EVAL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: uclanlp/plbart-python-en_XX
Model type: plbart
Experiment name: plbart_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
03/22/2023 17:42:51 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='uclanlp/plbart-python-en_XX', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='uclanlp/plbart-python-en_XX', model_type='plbart', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='uclanlp/plbart-python-en_XX', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 17:42:51 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 17:43:00 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../plbart_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 17:43:03 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:03<03:35,  3.92s/it]  4%|▎         | 2/56 [00:06<02:46,  3.08s/it]  5%|▌         | 3/56 [00:08<02:31,  2.85s/it]  7%|▋         | 4/56 [00:11<02:23,  2.76s/it]  9%|▉         | 5/56 [00:14<02:18,  2.72s/it] 11%|█         | 6/56 [00:16<02:16,  2.72s/it] 12%|█▎        | 7/56 [00:19<02:16,  2.79s/it] 14%|█▍        | 8/56 [00:22<02:16,  2.84s/it] 16%|█▌        | 9/56 [00:26<02:18,  2.94s/it] 18%|█▊        | 10/56 [00:29<02:15,  2.96s/it] 20%|█▉        | 11/56 [00:32<02:15,  3.00s/it] 21%|██▏       | 12/56 [00:35<02:12,  3.00s/it] 23%|██▎       | 13/56 [00:38<02:12,  3.07s/it] 25%|██▌       | 14/56 [00:41<02:12,  3.16s/it] 27%|██▋       | 15/56 [00:45<02:13,  3.26s/it] 29%|██▊       | 16/56 [00:48<02:13,  3.35s/it] 30%|███       | 17/56 [00:52<02:15,  3.47s/it] 32%|███▏      | 18/56 [00:56<02:14,  3.54s/it] 34%|███▍      | 19/56 [01:00<02:16,  3.68s/it] 36%|███▌      | 20/56 [01:04<02:17,  3.83s/it] 38%|███▊      | 21/56 [01:08<02:19,  3.98s/it] 39%|███▉      | 22/56 [01:12<02:15,  3.97s/it] 41%|████      | 23/56 [01:16<02:13,  4.04s/it] 43%|████▎     | 24/56 [01:21<02:11,  4.11s/it] 45%|████▍     | 25/56 [01:25<02:10,  4.19s/it] 46%|████▋     | 26/56 [01:30<02:09,  4.31s/it] 48%|████▊     | 27/56 [01:34<02:07,  4.40s/it] 50%|█████     | 28/56 [01:39<02:04,  4.44s/it] 52%|█████▏    | 29/56 [01:44<02:02,  4.53s/it] 54%|█████▎    | 30/56 [01:48<01:59,  4.58s/it] 55%|█████▌    | 31/56 [01:53<01:57,  4.68s/it] 57%|█████▋    | 32/56 [01:58<01:57,  4.88s/it] 59%|█████▉    | 33/56 [02:04<01:53,  4.94s/it] 61%|██████    | 34/56 [02:09<01:49,  4.97s/it] 62%|██████▎   | 35/56 [02:14<01:46,  5.05s/it] 64%|██████▍   | 36/56 [02:19<01:43,  5.19s/it] 66%|██████▌   | 37/56 [02:25<01:38,  5.19s/it] 68%|██████▊   | 38/56 [02:30<01:33,  5.22s/it] 70%|██████▉   | 39/56 [02:35<01:30,  5.30s/it] 71%|███████▏  | 40/56 [02:41<01:26,  5.38s/it] 73%|███████▎  | 41/56 [02:46<01:20,  5.34s/it] 75%|███████▌  | 42/56 [02:52<01:15,  5.37s/it] 77%|███████▋  | 43/56 [02:57<01:10,  5.45s/it] 79%|███████▊  | 44/56 [03:03<01:06,  5.52s/it] 80%|████████  | 45/56 [03:09<01:01,  5.61s/it] 82%|████████▏ | 46/56 [03:15<00:57,  5.74s/it] 84%|████████▍ | 47/56 [03:21<00:52,  5.79s/it] 86%|████████▌ | 48/56 [03:27<00:46,  5.85s/it] 88%|████████▊ | 49/56 [03:32<00:40,  5.85s/it] 89%|████████▉ | 50/56 [03:39<00:36,  6.10s/it] 91%|█████████ | 51/56 [03:45<00:30,  6.13s/it] 93%|█████████▎| 52/56 [03:52<00:24,  6.20s/it] 95%|█████████▍| 53/56 [03:58<00:18,  6.28s/it] 96%|█████████▋| 54/56 [04:05<00:12,  6.36s/it] 98%|█████████▊| 55/56 [04:11<00:06,  6.40s/it]100%|██████████| 56/56 [04:17<00:00,  6.21s/it]100%|██████████| 56/56 [04:17<00:00,  4.60s/it]
03/22/2023 17:47:21 - INFO - __main__ -     bleu-4 = 29.23 
03/22/2023 17:47:21 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:47:21 - INFO - __main__ -     ********************
tokenizer.decode(top_preds[0],: def findMinSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE mp [ arr [ j ] ] = mp . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT DEDENT minSum = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT minSum = min ( minSum , value ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMinSum ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def decToBinary ( arr , n ) : NEW_LINE INDENT binary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT binary += arr [ i ] NEW_LINE DEDENT return binary NEW_LINE DEDENT def decToBinary ( arr , n ) : NEW_LINE INDENT binary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT binary += arr [ i ] NEW_LINE DEDENT return binary NEW_LINE DEDENT def concat ( a , b , n , k ) : NEW_LINE INDENT len1 = len ( a ) NEW_LINE len2 = len ( b ) NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT a [ i ] = decToBinary ( a [ i ] , n ) NEW_LINE DEDENT for i in range ( len2 ) : NEW_LINE INDENT b [ i ] = decToBinary ( b [ i ] , n
tokenizer.decode(top_preds[0],: from bisect import bisect_left , bisect_right NEW_LINE def convert ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == '0' ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( n [ i ] ) NEW_LINE DEDENT DEDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countB ( A , C ) : NEW_LINE INDENT n = len ( A ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( int ( A [ i ] ) ) NEW_LINE DEDENT return len ( v ) NEW_LINE DEDENT def countCandB ( A , C ) : NEW_LINE INDENT n = len ( A ) NEW_LINE v = convert ( A
tokenizer.decode(top_preds[0],: def isvalid ( time ) : NEW_LINE INDENT if ( time <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( time <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( time <= 24 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isvalid ( time ) NEW_LINE DEDENT def isvalid ( time ) : NEW_LINE INDENT return ( time >= 24 ) NEW_LINE DEDENT def findMaxTime ( L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 24 , R + 1 ) : NEW_LINE INDENT if ( isvalid ( i ) ) : NEW_LINE INDENT res = res + i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findMaxTime ( L , R ) : NEW_LINE INDENT if ( L > R ) : NEW
tokenizer.decode(top_preds[0],: import math NEW_LINE def max intersection ( r1 , r2 , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT r1 = math . sqrt ( math . pow ( x1 , 2 ) + math . pow ( y1 , 2 ) + math . pow ( x2 , 2 ) ) NEW_LINE r2 = math . sqrt ( math . pow ( y2 , 2 ) + math . pow ( x1 , 2 ) ) NEW_LINE return max ( r1 , r2 ) NEW_LINE DEDENT r1 = 1 NEW_LINE r2 = 1 NEW_LINE x1 = 2 NEW_LINE y1 = 3 NEW_LINE x2 = 4 NEW_LINE y2 = 5 NEW_LINE print ( max intersection ( r1 , r2 , x1 , y1 , x2 , y2 ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def is undulating ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 19 NEW_LINE if ( is undulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def MSBNum ( n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) + 1 NEW_LINE return ( n & ( k - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( MSBNum ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def leftRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] , arr [ i + d ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def rightRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] , arr [ i + d ] = arr [ i ] , arr [ i + d ] NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE d = 5 NEW_LINE leftRotate ( arr , n , d ) NEW_LINE
tokenizer.decode(top_preds[0],: def findMissing ( arr , n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] == arr [ mid + 1 ] ) : NEW_LINE INDENT high = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: MAX = 26 NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , i , j , len1 , len2 ) : NEW_LINE INDENT if ( i == len1 and j == len2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp
tokenizer.decode(top_preds[0],: def findWays ( n ) : NEW_LINE INDENT fac1 = n - 1 NEW_LINE fac2 = n - 2 NEW_LINE if ( fac1 == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 1 ) : NEW_LINE INDENT print ( 3 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 1 ) : NEW_LINE INDENT print ( 4 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 2 ) : NEW_LINE INDENT print ( 5 ) NEW_LINE return NEW_LINE DEDENT if ( fac2 == 3 ) : NEW_LINE INDENT print ( 6 ) NEW_LINE return NEW_LINE DEDENT if ( fac1 == 2 ) : NEW_LINE INDENT print ( 7 ) NEW_LINE return NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def isComposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def kTrials ( n , d ) : NEW_LINE INDENT if ( n % d == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n > 4 ) : NEW_
tokenizer.decode(top_preds[0],: def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] = mp . get ( A [ j ] , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] = mp . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT DEDENT DEDENT for i in mp : NEW_LINE INDENT for j in mp : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE
tokenizer.decode(top_preds[0],: from math import * NEW_LINE def area_of_ sector ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 2 NEW_LINE print ( area_of_ sector ( a , b ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def minimumSwaps ( N ) : NEW_LINE INDENT a = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i - 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT if
tokenizer.decode(top_preds[0],: def findLIS ( arr , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range
tokenizer.decode(top_preds[0],: def seriesSum ( A ) : NEW_LINE INDENT return ( A * ( A + 1 ) ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 1 NEW_LINE print ( seriesSum ( A ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def sortArr ( a , b , n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE sortArr ( arr , 0 , len ( arr ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maxSquares ( n ) : NEW_LINE INDENT return n * ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( maxSquares ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: N = 3 NEW_LINE M = 3 NEW_LINE def countSets ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT ans += mat [ i ] [ j ] - mat [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 ,
tokenizer.decode(top_preds[0],: dp = [ [ 0 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE def pathCountDP ( m , n , k ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT dp [ m ] [ n ] = pathCountDP ( m - 1 , n , k ) + ( pathCountDP ( m - 1 , n - 1 , k ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
tokenizer.decode(top_preds[0],: def addTwoNumbers ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( carry == 0 ) : NEW_LINE INDENT x = x ^ y NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ x NEW_LINE carry = 1 NEW_LINE DEDENT DEDENT return x + y NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE y = 20 NEW_LINE print ( addTwoNumbers ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: Precompute ( ) : NEW_LINE INDENT prefixXOR = 0 NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT for i in range ( 1 , 100 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT return prefixXOR NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) ) NEW_LINE print ( precompute ( ) )
tokenizer.decode(top_preds[0],: def reverseArray ( arr , s , e ) : NEW_LINE INDENT for i in range ( s , e + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT DEDENT def generateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateArray ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maximumABs ( A , B ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == B [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( A [ i ] == ' A ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' ) : NEW_LINE INDENT B [ i ] = 1 NEW_LINE DEDENT elif ( A [ i ] == ' A ' ) : NEW_LINE INDENT B [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( A [ i ] == ' A ' ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE DEDENT elif ( B [ i ] == ' B ' )
tokenizer.decode(top_preds[0],: def longestSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE x = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE longestSubsequence ( arr , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countSubsets ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countSubsets ( arr , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairs ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( A , B , n , x , y ) : NEW_LINE INDENT if ( x < 0 or y < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] < B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE B = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( A ) NEW_LINE x = 2 NEW_LINE y = 2 NEW_LINE if ( isPossible ( A , B , n , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW
tokenizer.decode(top_preds[0],: def countMinOperations ( arr , N ) : NEW_LINE INDENT prefixSum = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT maximum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT if ( prefixSum [ j ] == prefixSum [ i ] ) : NEW_LINE INDENT groupSum [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT groupSum [ j ] -= 1 NEW_LINE DEDENT DEDENT maximum = max ( maximum , groupSum [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr )
tokenizer.decode(top_preds[0],: def solve ( A , N ) : NEW_LINE INDENT shift = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT shift += 1 NEW_LINE DEDENT print ( shift ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE solve ( A , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from collections import defaultdict NEW_LINE def smallestString ( s ) : NEW_LINE INDENT initial_ frequencies = defaultdict ( lambda : 0 ) NEW_LINE processed = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT initial_ frequencies [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT processed [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( processed [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == len ( s ) - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( processed [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == len ( s )
tokenizer.decode(top_preds[0],: import sys NEW_LINE def check ( arr , i , j , sm1 , sm2 , sm3 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sm1 [ i ] != - 1 ) : NEW_LINE INDENT return sm1 [ i ] NEW_LINE DEDENT if ( sm2 [ j ] != - 1 ) : NEW_LINE INDENT sm2 [ j ] = sm1 [ j ] NEW_LINE DEDENT if ( sm3 [ i ] != - 1 ) : NEW_LINE INDENT sm3 [ j ] = sm2 [ j ] NEW_LINE DEDENT if ( sm1 [ i ] != - 1 ) : NEW_LINE INDENT return sm1 [ i ] NEW_LINE DEDENT if ( sm2 [ j ] != - 1 ) : NEW_LINE INDENT return sm2 [ j ] NEW_LINE DEDENT if ( sm3 [ i ] != - 1 ) : NEW
tokenizer.decode(top_preds[0],: def maxSubArraySum ( a , n , k ) : NEW_LINE INDENT maxSubArraySum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] != a [ n - 1 ] ) : NEW_LINE INDENT maxSubArraySum += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxSubArraySum = max ( maxSubArraySum , a [ i ] ) NEW_LINE DEDENT DEDENT return maxSubArraySum NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxSubArraySum ( a , n , k ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def palindromicString ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE st = set ( ) NEW_LINE for ch in S : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Hash [ i ] == 2 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT elif ( Hash [ i ] == 3 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] > 0 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT if ( Hash [ i ] > 0 ) : NEW_LINE INDENT st . add ( S [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range (
tokenizer.decode(top_preds[0],: NO_OF_CHARS = 256 NEW_LINE def encrypt ( s , x ) : NEW_LINE INDENT x = x NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 0 ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: def count ( s ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( count ( s ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = r * r ; NEW_LINE return a ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 ; NEW_LINE print ( circlearea ( r ) ) ; NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def findSquares ( N ) : NEW_LINE INDENT block = [ 0 for i in range ( 8 ) ] NEW_LINE block [ 0 ] = 1 NEW_LINE block [ 1 ] = 1 NEW_LINE block [ 2 ] = 1 NEW_LINE for i in range ( 3 , N ) : NEW_LINE INDENT block [ i ] = block [ i - 1 ] + block [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( block [ i ] == 1 ) : NEW_LINE INDENT print ( block [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( block [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE findSquares ( N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def productOfPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product *= arr [ i ] * arr [ j ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productOfPairs ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 2 NEW_LINE isPossible ( x , y ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def checkPointIs inside rectangle ( point ) : NEW_LINE INDENT bottom_left = point [ 0 ] NEW_LINE top_right = point [ 1 ] NEW_LINE for i in range ( 2 , bottom_left + 1 ) : NEW_LINE INDENT bottom_right = point [ i ] NEW_LINE top_left = point [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , top_right + 1 ) : NEW_LINE INDENT bottom_left = point [ i ] NEW_LINE top_right = point [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , bottom_left + 1 ) : NEW_LINE INDENT for j in range ( 1 , top_right + 1 ) : NEW_LINE INDENT if ( i >= bottom_left and i <= top_right + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ ==
tokenizer.decode(top_preds[0],: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT elif ( K == 2 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( maxSum ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( sqrt ( n ) ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( sqrt ( n ) ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE
tokenizer.decode(top_preds[0],: mod = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 4 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 5 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 8 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == 8 ) : NEW
tokenizer.decode(top_preds[0],: def updateQuery ( arr , n , queries ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _
tokenizer.decode(top_preds[0],: def arePermutation ( a1 , b1 , a2 , b2 , n1 , n2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 0 NEW_LINE mul2 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += a1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += a2 [ i ] NEW_LINE mul1 = mul2 NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT sum1 += a1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += a2 [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main
tokenizer.decode(top_preds[0],: def avg ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( avg ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( max_element ) : NEW_LINE INDENT if ( freq [ j ] == 0 ) : NEW_LINE INDENT pairs += 1 NEW_LINE DEDENT elif ( freq [ j ] > 1 ) : NEW_LINE INDENT pairs += 1 NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n
tokenizer.decode(top_preds[0],: def minOperations ( m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n > m ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + minOperations ( m , n // 2 ) ; NEW_LINE DEDENT return minOperations ( m , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 ; NEW_LINE n = 10 ; NEW_LINE print ( minOperations ( m , n ) ) ; NEW_
tokenizer.decode(top_preds[0],: from math import log10 , floor NEW_LINE def reverseDigits ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 19 NEW_LINE print ( reverseDigits ( num ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( len ( arr1 ) ) : NEW_LINE INDENT for j in range ( len ( arr2 ) ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * M NEW_LINE countTW = [ 0 ] * M NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( M
tokenizer.decode(top_preds[0],: def diagonals ( n ) : NEW_LINE INDENT diagonals = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT diagonals += i NEW_LINE DEDENT return diagonals NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( diagonals ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def kthSubStr ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( k > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT cnt = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE cnt [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += cnt [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] NEW_LINE cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range (
tokenizer.decode(top_preds[0],: def printArrangement ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( 12 , 24 ) : NEW_LINE INDENT format1 = arr1 [ i ] NEW_LINE format2 = arr2 [ i ] NEW_LINE if ( format1 < format2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def sort ( arr , n ) : NEW_LINE INDENT format1 = str ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT format2 = str ( arr [ i ] ) NEW_LINE if ( compare ( arr1 , arr2 ) ) : NEW_LINE
tokenizer.decode(top_preds[0],: def minDiff ( a , n ) : NEW_LINE INDENT min_diff = a [ 0 ] - a [ 1 ] NEW_LINE max_diff = a [ 1 ] - a [ 0 ] NEW_LINE return min_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minDiff ( a , n ) ) NEW_LINE DEDENT
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
