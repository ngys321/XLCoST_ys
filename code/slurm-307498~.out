@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
probing_case 도입


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ RUNNING SCRIPT: job_n_NoAug_py_codet5_syn.sh

Wed Mar 22 17:13:53 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 465.19.01    Driver Version: 465.19.01    CUDA Version: 11.3     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  On   | 00000000:A1:00.0 Off |                  N/A |
| 53%   49C    P8    27W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2022 NVIDIA Corporation
Built on Wed_Jun__8_16:49:14_PDT_2022
Cuda compilation tools, release 11.7, V11.7.99
Build cuda_11.7.r11.7/compiler.31442593_0
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START TRAIN @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: Salesforce/codet5-base
Model type: codet5
Experiment name: codet5_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
/home/ysnamgoong42/ws/XLCoST/code
03/22/2023 17:13:58 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='Salesforce/codet5-base', dev_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.py', do_eval=True, do_lower_case=False, do_test=False, do_train=True, eval_batch_size=16, eval_steps=2500, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path=None, local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='Salesforce/codet5-base', model_type='codet5', no_cuda=False, num_train_epochs=10.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename=None, tokenizer_name='Salesforce/codet5-base', train_batch_size=16, train_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.py', train_steps=5000, warmup_steps=0, weight_decay=0.0)
03/22/2023 17:13:58 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 17:14:11 - INFO - __main__ -   *** Example ***
03/22/2023 17:14:11 - INFO - __main__ -   idx: 0
03/22/2023 17:14:11 - INFO - __main__ -   source_tokens: ['<s>', 'Maximum', '_Prefix', '_Sum', '_possible', '_by', '_merging', '_two', '_given', '_arrays', '_|', '_Python', '3', '_implementation', '_of', '_the', '_above', '_approach', '_;', '_Sto', 'res', '_the', '_maximum', '_prefix', '_sum', '_of', '_the', '_array', '_A', '_[', '_]', '_;', '_Tra', 'verse', '_the', '_array', '_A', '_[', '_]', '_;', '_Sto', 'res', '_the', '_maximum', '_prefix', '_sum', '_of', '_the', '_array', '_B', '_[', '_]', '_;', '_Tra', 'verse', '_the', '_array', '_B', '_[', '_]', '_;', '_Driver', '_code', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   source_ids: 1 13528 10139 9352 3323 635 17256 2795 864 5352 571 6600 23 4471 434 326 5721 17504 274 20296 455 326 4207 1633 2142 434 326 526 432 306 308 274 2197 2476 326 526 432 306 308 274 20296 455 326 4207 1633 2142 434 326 526 605 306 308 274 2197 2476 326 526 605 306 308 274 9396 981 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_tokens: ['<s>', 'def', '_max', 'Pres', 'um', '_(', '_a', '_,', '_b', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_X', '_=', '_max', '_(', '_a', '_[', '_0', '_]', '_,', '_0', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_1', '_,', '_len', '_(', '_a', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_a', '_[', '_i', '_]', '_+=', '_a', '_[', '_i', '_-', '_1', '_]', '_NEW', '_', 'LINE', '_X', '_=', '_max', '_(', '_X', '_,', '_a', '_[', '_i', '_]', '_)', '_NEW', '_', 'LINE', '_DE', 'DENT', '_Y', '_=', '_max', '_(', '_b', '_[', '_0', '_]', '_,', '_0', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_1', '_,', '_len', '_(', '_b', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_b', '_[', '_i', '_]', '_+=', '_b', '_[', '_i', '_-', '_1', '_]', '_NEW', '_', 'LINE', '_Y', '_=', '_max', '_(', '_Y', '_,', '_b', '_[', '_i', '_]', '_)', '_NEW', '_', 'LINE', '_DE', 'DENT', '_return', '_X', '_+', '_Y', '_NEW', '_', 'LINE', '_DE', 'DENT', '_A', '_=', '_[', '_2', '_,', '_-', '_1', '_,', '_4', '_,', '_-', '_5', '_]', '_NEW', '_', 'LINE', '_B', '_=', '_[', '_4', '_,', '_-', '_3', '_,', '_12', '_,', '_4', '_,', '_-', '_3', '_]', '_NEW', '_', 'LINE', '_print', '_(', '_max', 'Pres', 'um', '_(', '_A', '_,', '_B', '_)', '_)', '_NEW', '_', 'LINE', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   target_ids: 1 536 943 12236 379 261 279 269 324 262 294 12887 67 5997 30009 1139 273 943 261 279 306 374 308 269 374 262 12887 67 5997 364 277 316 1048 261 404 269 562 261 279 262 262 294 12887 67 5997 30009 279 306 277 308 1011 279 306 277 300 404 308 12887 67 5997 1139 273 943 261 1139 269 279 306 277 308 262 12887 67 5997 2030 18981 1624 273 943 261 324 306 374 308 269 374 262 12887 67 5997 364 277 316 1048 261 404 269 562 261 324 262 262 294 12887 67 5997 30009 324 306 277 308 1011 324 306 277 300 404 308 12887 67 5997 1624 273 943 261 1624 269 324 306 277 308 262 12887 67 5997 2030 18981 327 1139 397 1624 12887 67 5997 2030 18981 432 273 306 576 269 300 404 269 1059 269 300 1381 308 12887 67 5997 605 273 306 1059 269 300 890 269 2593 269 1059 269 300 890 308 12887 67 5997 1172 261 943 12236 379 261 432 269 605 262 262 12887 67 5997 2 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   *** Example ***
03/22/2023 17:14:11 - INFO - __main__ -   idx: 1
03/22/2023 17:14:11 - INFO - __main__ -   source_tokens: ['<s>', 'Check', '_if', '_a', '_number', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_positive', '_perfect', '_c', 'ubes', '_|', '_Python', '3', '_program', '_for', '_the', '_above', '_approach', '_;', '_Function', '_to', '_check', '_if', '_N', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_perfect', '_c', 'ubes', '_or', '_not', '_;', '_If', '_it', '_is', '_same', '_return', '_true', '_;', '_;', '_If', '_the', '_curr', '_smaller', '_than', '_n', '_increment', '_the', '_lo', '_;', '_If', '_the', '_curr', '_is', '_greater', '_than', '_curr', '_decrement', '_the', '_hi', '_;', '_Driver', '_Code', '_;', '_Function', '_call', '_to', '_check', '_if', '_N', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_perfect', '_c', 'ubes', '_or', '_not', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   source_ids: 1 1564 309 279 1300 848 506 10584 487 2142 434 2795 6895 24746 276 23317 571 6600 23 5402 364 326 5721 17504 274 4284 358 866 309 423 848 506 10584 487 2142 434 2795 24746 276 23317 578 486 274 971 518 353 1967 327 638 274 274 971 326 4306 10648 2353 290 5504 326 437 274 971 326 4306 353 6802 2353 4306 15267 326 10118 274 9396 3356 274 4284 745 358 866 309 423 848 506 10584 487 2142 434 2795 24746 276 23317 578 486 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_tokens: ['<s>', 'import', '_math', '_NEW', '_', 'LINE', '_def', '_sum', 'Of', 'Two', 'C', 'ubes', '_(', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_lo', '_=', '_1', '_NEW', '_', 'LINE', '_hi', '_=', '_round', '_(', '_math', '_.', '_pow', '_(', '_n', '_,', '_1', '_/', '_3', '_)', '_)', '_NEW', '_', 'LINE', '_while', '_(', '_lo', '_<=', '_hi', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_curr', '_=', '_(', '_lo', '_*', '_lo', '_*', '_lo', '_+', '_hi', '_*', '_hi', '_*', '_hi', '_)', '_NEW', '_', 'LINE', '_if', '_(', '_curr', '_==', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_return', '_True', '_NEW', '_', 'LINE', '_DE', 'DENT', '_if', '_(', '_curr', '_<', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_lo', '_+=', '_1', '_NEW', '_', 'LINE', '_DE', 'DENT', '_else', '_:', '_NEW', '_', 'LINE', '_INDENT', '_hi', '_-=', '_1', '_NEW', '_', 'LINE', '_DE', 'DENT', '_DE', 'DENT', '_return', '_False', '_NEW', '_', 'LINE', '_DE', 'DENT', '_N', '_=', '_28', '_NEW', '_', 'LINE', '_if', '_(', '_sum', 'Of', 'Two', 'C', 'ubes', '_(', '_N', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_print', '_(', '_"', '_True', '_"', '_)', '_NEW', '_', 'LINE', '_DE', 'DENT', '_else', '_:', '_NEW', '_', 'LINE', '_INDENT', '_print', '_(', '_"', '_False', '_"', '_)', '_NEW', '_', 'LINE', '_DE', 'DENT', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   target_ids: 1 5666 4233 12887 67 5997 1652 2142 951 11710 39 23317 261 290 262 294 12887 67 5997 30009 437 273 404 12887 67 5997 10118 273 3643 261 4233 263 7602 261 290 269 404 342 890 262 262 12887 67 5997 1323 261 437 1648 10118 262 294 12887 67 5997 30009 4306 273 261 437 380 437 380 437 397 10118 380 10118 380 10118 262 12887 67 5997 309 261 4306 422 290 262 294 12887 67 5997 30009 327 1053 12887 67 5997 2030 18981 309 261 4306 411 290 262 294 12887 67 5997 30009 437 1011 404 12887 67 5997 2030 18981 469 294 12887 67 5997 30009 10118 3947 404 12887 67 5997 2030 18981 2030 18981 327 1083 12887 67 5997 2030 18981 423 273 9131 12887 67 5997 309 261 2142 951 11710 39 23317 261 423 262 262 294 12887 67 5997 30009 1172 261 315 1053 315 262 12887 67 5997 2030 18981 469 294 12887 67 5997 30009 1172 261 315 1083 315 262 12887 67 5997 2030 18981 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   *** Example ***
03/22/2023 17:14:11 - INFO - __main__ -   idx: 2
03/22/2023 17:14:11 - INFO - __main__ -   source_tokens: ['<s>', 'Generate', '_an', '_N', '_|', '_Python', '3', '_program', '_for', '_the', '_above', '_approach', '_;', '_Function', '_to', '_generate', '_all', '_prime', '_numbers', '_u', 'pto', '_10', '_^', '_6', '_;', '_Initialize', '_s', 'ieve', '_[', '_]', '_as', '_1', '_;', '_Iterate', '_over', '_the', '_range', '_[', '_2', '_,', '_N', '_]', '_;', '_If', '_current', '_element', '_is', '_non', '_-', '_prime', '_;', '_Make', '_all', '_multi', 'ples', '_of', '_i', '_as', '_0', '_;', '_Function', '_to', '_construct', '_an', '_array', '_A', '_[', '_]', '_satisf', 'ying', '_the', '_given', '_conditions', '_;', '_Sto', 'res', '_the', '_result', 'ant', '_array', '_;', '_Sto', 'res', '_all', '_prime', '_numbers', '_;', '_S', 'ieve', '_of', '_E', 'ra', 'st', 'ost', 'h', 'en', 'es', '_;', '_Append', '_the', '_integer', '_i', '_if', '_it', '_is', '_a', '_prime', '_;', '_Indicates', '_current', '_position', '_in', '_list', '_of', '_prime', '_numbers', '_;', '_Tra', 'verse', '_the', '_array', '_arr', '_[', '_]', '_;', '_If', '_already', '_filled', '_with', '_another', '_prime', '_number', '_;', '_If', '_A', '_[', '_i', '_]', '_is', '_not', '_filled', '_but', '_A', '_[', '_ind', '_]', '_is', '_filled', '_;', '_Store', '_A', '_[', '_i', '_]', '_=', '_A', '_[', '_ind', '_]', '_;', '_If', '_none', '_of', '_them', '_were', '_filled', '_;', '_To', '_make', '_sure', '_A', '_[', '_i', '_]', '_does', '_not', '_affect', '_other', '_values', '_,', '_store', '_next', '_prime', '_number', '_;', '_Print', '_the', '_result', 'ant', '_array', '_;', '_Driver', '_Code', '_;', '_Function', '_Call', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   source_ids: 1 4625 392 423 571 6600 23 5402 364 326 5721 17504 274 4284 358 2103 777 17014 5600 582 21910 1728 3602 1666 274 9190 272 21271 306 308 487 404 274 11436 1879 326 1048 306 576 269 423 308 274 971 783 930 353 1661 300 17014 274 4344 777 3309 6089 434 277 487 374 274 4284 358 4872 392 526 432 306 308 9281 14946 326 864 4636 274 20296 455 326 563 970 526 274 20296 455 777 17014 5600 274 348 21271 434 512 354 334 669 76 275 281 274 6181 326 3571 277 309 518 353 279 17014 274 18336 783 1754 316 666 434 17014 5600 274 2197 2476 326 526 2454 306 308 274 971 1818 6300 598 4042 17014 1300 274 971 432 306 277 308 353 486 6300 1496 432 306 1547 308 353 6300 274 4994 432 306 277 308 273 432 306 1547 308 274 971 6555 434 2182 4591 6300 274 2974 1221 3071 432 306 277 308 1552 486 13418 1308 924 269 1707 1024 17014 1300 274 3038 326 563 970 526 274 9396 3356 274 4284 3049 2 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_tokens: ['<s>', 's', 'ieve', '_=', '_[', '_1', '_]', '_*', '_(', '_1000000', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_def', '_s', 'ieve', 'Of', 'Pr', 'imes', '_(', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_global', '_s', 'ieve', '_NEW', '_', 'LINE', '_N', '_=', '_1000000', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_2', '_,', '_N', '_+', '_1', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_if', '_i', '_*', '_i', '_>', '_N', '_:', '_NEW', '_', 'LINE', '_INDENT', '_break', '_NEW', '_', 'LINE', '_DE', 'DENT', '_if', '_(', '_s', 'ieve', '_[', '_i', '_]', '_==', '_0', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_continue', '_NEW', '_', 'LINE', '_DE', 'DENT', '_for', '_j', '_in', '_range', '_(', '_i', '_*', '_i', '_,', '_N', '_+', '_1', '_,', '_i', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_s', 'ieve', '_[', '_j', '_]', '_=', '_0', '_NEW', '_', 'LINE', '_DE', 'DENT', '_DE', 'DENT', '_DE', 'DENT', '_def', '_getArray', '_(', '_arr', '_,', '_N', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_global', '_s', 'ieve', '_NEW', '_', 'LINE', '_A', '_=', '_[', '_0', '_]', '_*', '_N', '_NEW', '_', 'LINE', '_v', '_=', '_[', '_]', '_NEW', '_', 'LINE', '_s', 'ieve', 'Of', 'Pr', 'imes', '_(', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_2', '_,', '_int', '_(', '_1', 'e', '5', '_)', '_+', '_1', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_if', '_(', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   target_ids: 1 87 21271 273 306 404 308 380 261 15088 397 404 262 12887 67 5997 1652 272 21271 951 2050 4485 261 262 294 12887 67 5997 30009 2552 272 21271 12887 67 5997 423 273 15088 12887 67 5997 364 277 316 1048 261 576 269 423 397 404 262 294 12887 67 5997 30009 309 277 380 277 405 423 294 12887 67 5997 30009 898 12887 67 5997 2030 18981 309 261 272 21271 306 277 308 422 374 262 294 12887 67 5997 30009 1324 12887 67 5997 2030 18981 364 525 316 1048 261 277 380 277 269 423 397 404 269 277 262 294 12887 67 5997 30009 272 21271 306 525 308 273 374 12887 67 5997 2030 18981 2030 18981 2030 18981 1652 12634 261 2454 269 423 262 294 12887 67 5997 30009 2552 272 21271 12887 67 5997 432 273 306 374 308 380 423 12887 67 5997 331 273 306 308 12887 67 5997 272 21271 951 2050 4485 261 262 12887 67 5997 364 277 316 1048 261 576 269 509 261 404 73 25 262 397 404 262 294 12887 67 5997 30009 309 261 2
03/22/2023 17:14:11 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:14:11 - INFO - __main__ -   *** Example ***
03/22/2023 17:14:11 - INFO - __main__ -   idx: 3
03/22/2023 17:14:11 - INFO - __main__ -   source_tokens: ['<s>', 'N', 'th', '_natural', '_number', '_after', '_removing', '_all', '_numbers', '_consisting', '_of', '_the', '_digit', '_9', '_|', '_Function', '_to', '_find', '_N', 'th', '_number', '_in', '_base', '_9', '_;', '_Sto', 'res', '_the', '_N', 'th', '_number', '_;', '_Iterate', '_while', '_N', '_is', '_greater', '_than', '_0', '_;', '_Update', '_result', '_;', '_Div', 'ide', '_N', '_by', '_9', '_;', '_Multi', 'ply', '_p', '_by', '_10', '_;', '_Return', '_result', '_;', '_Driver', '_Code', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   source_ids: 1 50 451 15145 1300 1839 9427 777 5600 23570 434 326 8035 2468 571 4284 358 1104 423 451 1300 316 1026 2468 274 20296 455 326 423 451 1300 274 11436 1323 423 353 6802 2353 374 274 2315 563 274 21411 831 423 635 2468 274 5991 1283 293 635 1728 274 2000 563 274 9396 3356 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_tokens: ['<s>', 'def', '_find', 'N', 'th', 'Number', '_(', '_N', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_result', '_=', '_0', '_NEW', '_', 'LINE', '_p', '_=', '_1', '_NEW', '_', 'LINE', '_while', '_(', '_N', '_>', '_0', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_result', '_+=', '_(', '_p', '_*', '_(', '_N', '_%', '_9', '_)', '_)', '_NEW', '_', 'LINE', '_N', '_=', '_N', '_//', '_9', '_NEW', '_', 'LINE', '_p', '_=', '_p', '_*', '_10', '_NEW', '_', 'LINE', '_DE', 'DENT', '_return', '_result', '_NEW', '_', 'LINE', '_DE', 'DENT', '_if', '___', 'name', '__', '_==', "_'", '__', '__', '_main', '__', '__', "_'", '_:', '_NEW', '_', 'LINE', '_INDENT', '_N', '_=', '_9', '_NEW', '_', 'LINE', '_print', '_(', '_find', 'N', 'th', 'Number', '_(', '_N', '_)', '_)', '_NEW', '_', 'LINE', '_DE', 'DENT', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   target_ids: 1 536 1104 50 451 1854 261 423 262 294 12887 67 5997 30009 563 273 374 12887 67 5997 293 273 404 12887 67 5997 1323 261 423 405 374 262 294 12887 67 5997 30009 563 1011 261 293 380 261 423 738 2468 262 262 12887 67 5997 423 273 423 368 2468 12887 67 5997 293 273 293 380 1728 12887 67 5997 2030 18981 327 563 12887 67 5997 2030 18981 309 1001 529 972 422 296 389 389 2774 389 389 296 294 12887 67 5997 30009 423 273 2468 12887 67 5997 1172 261 1104 50 451 1854 261 423 262 262 12887 67 5997 2030 18981 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   *** Example ***
03/22/2023 17:14:11 - INFO - __main__ -   idx: 4
03/22/2023 17:14:11 - INFO - __main__ -   source_tokens: ['<s>', 'Check', '_if', '_an', '_integer', '_is', '_rotation', '_of', '_another', '_given', '_integer', '_|', '_Python', '3', '_implementation', '_of', '_the', '_approach', '_;', '_Function', '_to', '_check', '_if', '_the', '_integer', '_A', '_is', '_a', '_rotation', '_of', '_the', '_integer', '_B', '_;', '_Sto', 'res', '_the', '_count', '_of', '_digits', '_in', '_A', '_;', '_Sto', 'res', '_the', '_count', '_of', '_digits', '_in', '_B', '_;', '_If', '_dig', '1', '_not', '_equal', '_to', '_dig', '2', '_;', '_Sto', 'res', '_position', '_of', '_first', '_digit', '_;', '_Sto', 'res', '_the', '_first', '_digit', '_;', '_Rotate', '_the', '_digits', '_of', '_the', '_integer', '_;', '_If', '_A', '_is', '_equal', '_to', '_B', '_;', '_If', '_A', '_is', '_equal', '_to', '_the', '_initial', '_value', '_of', '_integer', '_A', '_;', '_Driver', '_code', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   source_ids: 1 1564 309 392 3571 353 6752 434 4042 864 3571 571 6600 23 4471 434 326 17504 274 4284 358 866 309 326 3571 432 353 279 6752 434 326 3571 605 274 20296 455 326 1056 434 6815 316 432 274 20296 455 326 1056 434 6815 316 605 274 971 3097 21 486 3959 358 3097 22 274 20296 455 1754 434 1122 8035 274 20296 455 326 1122 8035 274 24280 326 6815 434 326 3571 274 971 432 353 3959 358 605 274 971 432 353 3959 358 326 2172 460 434 3571 432 274 9396 981 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:14:11 - INFO - __main__ -   target_tokens: ['<s>', 'import', '_math', '_NEW', '_', 'LINE', '_def', '_check', '_(', '_A', '_,', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_if', '_(', '_A', '_==', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_return', '_1', '_NEW', '_', 'LINE', '_DE', 'DENT', '_dig', '1', '_=', '_math', '_.', '_floor', '_(', '_math', '_.', '_log', '10', '_(', '_A', '_)', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_dig', '2', '_=', '_math', '_.', '_floor', '_(', '_math', '_.', '_log', '10', '_(', '_B', '_)', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_if', '_(', '_dig', '1', '_!=', '_dig', '2', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_return', '_0', '_NEW', '_', 'LINE', '_DE', 'DENT', '_temp', '_=', '_A', '_NEW', '_', 'LINE', '_while', '_(', '_True', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_power', '_=', '_pow', '_(', '_10', '_,', '_dig', '1', '_-', '_1', '_)', '_NEW', '_', 'LINE', '_first', 'digit', '_=', '_A', '_//', '_power', '_NEW', '_', 'LINE', '_A', '_=', '_A', '_-', '_first', 'digit', '_*', '_power', '_NEW', '_', 'LINE', '_A', '_=', '_A', '_*', '_10', '_+', '_first', 'digit', '_NEW', '_', 'LINE', '_if', '_(', '_A', '_==', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_return', '_1', '_NEW', '_', 'LINE', '_DE', 'DENT', '_if', '_(', '_A', '_==', '_temp', '_)', '_:', '_NEW', '_', 'LINE', '_INDENT', '_return', '_0', '_NEW', '_', 'LINE', '_DE', 'DENT', '_DE', 'DENT', '_DE', 'DENT', '_A', '_,', '_B', '</s>']
03/22/2023 17:14:11 - INFO - __main__ -   target_ids: 1 5666 4233 12887 67 5997 1652 866 261 432 269 605 262 294 12887 67 5997 30009 309 261 432 422 605 262 294 12887 67 5997 30009 327 404 12887 67 5997 2030 18981 3097 21 273 4233 263 6346 261 4233 263 613 2163 261 432 262 397 404 262 12887 67 5997 3097 22 273 4233 263 6346 261 4233 263 613 2163 261 605 262 397 404 262 12887 67 5997 309 261 3097 21 480 3097 22 262 294 12887 67 5997 30009 327 374 12887 67 5997 2030 18981 1906 273 432 12887 67 5997 1323 261 1053 262 294 12887 67 5997 30009 7212 273 7602 261 1728 269 3097 21 300 404 262 12887 67 5997 1122 11052 273 432 368 7212 12887 67 5997 432 273 432 300 1122 11052 380 7212 12887 67 5997 432 273 432 380 1728 397 1122 11052 12887 67 5997 309 261 432 422 605 262 294 12887 67 5997 30009 327 404 12887 67 5997 2030 18981 309 261 432 422 1906 262 294 12887 67 5997 30009 327 374 12887 67 5997 2030 18981 2030 18981 2030 18981 432 269 605 2
03/22/2023 17:14:11 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
/home/ysnamgoong42/miniconda3/envs/xlcost/lib/python3.8/site-packages/transformers/optimization.py:306: FutureWarning: This implementation of AdamW is deprecated and will be removed in a future version. Use the PyTorch implementation torch.optim.AdamW instead, or set `no_deprecation_warning=True` to disable this warning
  warnings.warn(
03/22/2023 17:14:27 - INFO - __main__ -   ***** Running training *****
03/22/2023 17:14:27 - INFO - __main__ -     Num examples = 9263
03/22/2023 17:14:27 - INFO - __main__ -     Batch size = 16
03/22/2023 17:14:27 - INFO - __main__ -     Num epoch = 9
03/22/2023 17:15:04 - INFO - __main__ -     step 100 loss 1.6409
03/22/2023 17:15:40 - INFO - __main__ -     step 200 loss 1.2994
03/22/2023 17:16:16 - INFO - __main__ -     step 300 loss 1.1506
03/22/2023 17:16:53 - INFO - __main__ -     step 400 loss 1.0655
03/22/2023 17:17:28 - INFO - __main__ -     step 500 loss 1.0071
03/22/2023 17:18:05 - INFO - __main__ -     step 600 loss 0.9616
03/22/2023 17:18:41 - INFO - __main__ -     step 700 loss 0.9243
03/22/2023 17:19:17 - INFO - __main__ -     step 800 loss 0.8951
03/22/2023 17:19:53 - INFO - __main__ -     step 900 loss 0.8705
03/22/2023 17:20:29 - INFO - __main__ -     step 1000 loss 0.849
03/22/2023 17:21:05 - INFO - __main__ -     step 1100 loss 0.8304
03/22/2023 17:21:27 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:21:27 - INFO - __main__ -     Num examples = 472
03/22/2023 17:21:27 - INFO - __main__ -     Batch size = 16
03/22/2023 17:21:30 - INFO - __main__ -     eval_ppl = 1.78192
03/22/2023 17:21:30 - INFO - __main__ -     global_step = 1157
03/22/2023 17:21:30 - INFO - __main__ -     train_loss = 0.8208
03/22/2023 17:21:30 - INFO - __main__ -     ********************
03/22/2023 17:21:34 - INFO - __main__ -     Best ppl:1.78192
03/22/2023 17:21:34 - INFO - __main__ -     ********************
03/22/2023 17:31:29 - INFO - __main__ -     bleu-4 = 23.92 
03/22/2023 17:31:29 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:31:29 - INFO - __main__ -     ********************
03/22/2023 17:31:29 - INFO - __main__ -     Best bleu:23.92
03/22/2023 17:31:29 - INFO - __main__ -     ********************
03/22/2023 17:31:49 - INFO - __main__ -     step 1200 loss 0.6246
03/22/2023 17:32:25 - INFO - __main__ -     step 1300 loss 0.6157
03/22/2023 17:33:01 - INFO - __main__ -     step 1400 loss 0.6108
03/22/2023 17:33:36 - INFO - __main__ -     step 1500 loss 0.6078
03/22/2023 17:34:12 - INFO - __main__ -     step 1600 loss 0.604
03/22/2023 17:34:48 - INFO - __main__ -     step 1700 loss 0.5993
03/22/2023 17:35:25 - INFO - __main__ -     step 1800 loss 0.5951
03/22/2023 17:36:00 - INFO - __main__ -     step 1900 loss 0.5905
03/22/2023 17:36:36 - INFO - __main__ -     step 2000 loss 0.5861
03/22/2023 17:37:12 - INFO - __main__ -     step 2100 loss 0.5825
03/22/2023 17:37:49 - INFO - __main__ -     step 2200 loss 0.5791
03/22/2023 17:38:25 - INFO - __main__ -     step 2300 loss 0.5748
03/22/2023 17:38:30 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:38:30 - INFO - __main__ -     Num examples = 472
03/22/2023 17:38:30 - INFO - __main__ -     Batch size = 16
03/22/2023 17:38:33 - INFO - __main__ -     eval_ppl = 1.69827
03/22/2023 17:38:33 - INFO - __main__ -     global_step = 2314
03/22/2023 17:38:33 - INFO - __main__ -     train_loss = 0.5744
03/22/2023 17:38:33 - INFO - __main__ -     ********************
03/22/2023 17:38:37 - INFO - __main__ -     Best ppl:1.69827
03/22/2023 17:38:37 - INFO - __main__ -     ********************
03/22/2023 17:48:45 - INFO - __main__ -     bleu-4 = 26.61 
03/22/2023 17:48:45 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:48:45 - INFO - __main__ -     ********************
03/22/2023 17:48:45 - INFO - __main__ -     Best bleu:26.61
03/22/2023 17:48:45 - INFO - __main__ -     ********************
03/22/2023 17:49:20 - INFO - __main__ -     step 2400 loss 0.5253
03/22/2023 17:49:56 - INFO - __main__ -     step 2500 loss 0.5234
03/22/2023 17:50:32 - INFO - __main__ -     step 2600 loss 0.5206
03/22/2023 17:51:08 - INFO - __main__ -     step 2700 loss 0.5184
03/22/2023 17:51:44 - INFO - __main__ -     step 2800 loss 0.5174
03/22/2023 17:52:20 - INFO - __main__ -     step 2900 loss 0.5142
03/22/2023 17:52:56 - INFO - __main__ -     step 3000 loss 0.5115
03/22/2023 17:53:32 - INFO - __main__ -     step 3100 loss 0.5095
03/22/2023 17:54:08 - INFO - __main__ -     step 3200 loss 0.5069
03/22/2023 17:54:44 - INFO - __main__ -     step 3300 loss 0.5051
03/22/2023 17:55:20 - INFO - __main__ -     step 3400 loss 0.5028
03/22/2023 17:55:46 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:55:46 - INFO - __main__ -     Num examples = 472
03/22/2023 17:55:46 - INFO - __main__ -     Batch size = 16
03/22/2023 17:55:49 - INFO - __main__ -     eval_ppl = 1.66298
03/22/2023 17:55:49 - INFO - __main__ -     global_step = 3471
03/22/2023 17:55:49 - INFO - __main__ -     train_loss = 0.5012
03/22/2023 17:55:49 - INFO - __main__ -     ********************
03/22/2023 17:55:53 - INFO - __main__ -     Best ppl:1.66298
03/22/2023 17:55:53 - INFO - __main__ -     ********************
03/22/2023 18:06:06 - INFO - __main__ -     bleu-4 = 27.74 
03/22/2023 18:06:06 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:06:06 - INFO - __main__ -     ********************
03/22/2023 18:06:06 - INFO - __main__ -     Best bleu:27.74
03/22/2023 18:06:06 - INFO - __main__ -     ********************
03/22/2023 18:06:21 - INFO - __main__ -     step 3500 loss 0.4619
03/22/2023 18:06:56 - INFO - __main__ -     step 3600 loss 0.4658
03/22/2023 18:07:32 - INFO - __main__ -     step 3700 loss 0.4679
03/22/2023 18:08:08 - INFO - __main__ -     step 3800 loss 0.4665
03/22/2023 18:08:45 - INFO - __main__ -     step 3900 loss 0.4656
03/22/2023 18:09:21 - INFO - __main__ -     step 4000 loss 0.4632
03/22/2023 18:09:57 - INFO - __main__ -     step 4100 loss 0.4615
03/22/2023 18:10:33 - INFO - __main__ -     step 4200 loss 0.4594
03/22/2023 18:11:09 - INFO - __main__ -     step 4300 loss 0.4574
03/22/2023 18:11:45 - INFO - __main__ -     step 4400 loss 0.4564
03/22/2023 18:12:21 - INFO - __main__ -     step 4500 loss 0.4553
03/22/2023 18:12:57 - INFO - __main__ -     step 4600 loss 0.4537
03/22/2023 18:13:07 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 18:13:07 - INFO - __main__ -     Num examples = 472
03/22/2023 18:13:07 - INFO - __main__ -     Batch size = 16
03/22/2023 18:13:11 - INFO - __main__ -     eval_ppl = 1.63213
03/22/2023 18:13:11 - INFO - __main__ -     global_step = 4628
03/22/2023 18:13:11 - INFO - __main__ -     train_loss = 0.4536
03/22/2023 18:13:11 - INFO - __main__ -     ********************
03/22/2023 18:13:17 - INFO - __main__ -     Best ppl:1.63213
03/22/2023 18:13:17 - INFO - __main__ -     ********************
03/22/2023 18:23:27 - INFO - __main__ -     bleu-4 = 27.98 
03/22/2023 18:23:27 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:23:27 - INFO - __main__ -     ********************
03/22/2023 18:23:27 - INFO - __main__ -     Best bleu:27.98
03/22/2023 18:23:27 - INFO - __main__ -     ********************
03/22/2023 18:23:57 - INFO - __main__ -     step 4700 loss 0.4394
03/22/2023 18:24:33 - INFO - __main__ -     step 4800 loss 0.4355
03/22/2023 18:25:09 - INFO - __main__ -     step 4900 loss 0.434
03/22/2023 18:25:45 - INFO - __main__ -     step 5000 loss 0.4352
03/22/2023 18:26:21 - INFO - __main__ -     step 5100 loss 0.4347
03/22/2023 18:26:57 - INFO - __main__ -     step 5200 loss 0.4328
03/22/2023 18:27:33 - INFO - __main__ -     step 5300 loss 0.4318
03/22/2023 18:28:09 - INFO - __main__ -     step 5400 loss 0.4307
03/22/2023 18:28:45 - INFO - __main__ -     step 5500 loss 0.4297
03/22/2023 18:29:21 - INFO - __main__ -     step 5600 loss 0.4291
03/22/2023 18:29:57 - INFO - __main__ -     step 5700 loss 0.4286
03/22/2023 18:30:28 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 18:30:28 - INFO - __main__ -     Num examples = 472
03/22/2023 18:30:28 - INFO - __main__ -     Batch size = 16
03/22/2023 18:30:31 - INFO - __main__ -     eval_ppl = 1.6307
03/22/2023 18:30:31 - INFO - __main__ -     global_step = 5785
03/22/2023 18:30:31 - INFO - __main__ -     train_loss = 0.428
03/22/2023 18:30:31 - INFO - __main__ -     ********************
03/22/2023 18:30:37 - INFO - __main__ -     Best ppl:1.6307
03/22/2023 18:30:37 - INFO - __main__ -     ********************
03/22/2023 18:41:00 - INFO - __main__ -     bleu-4 = 28.21 
03/22/2023 18:41:00 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:41:00 - INFO - __main__ -     ********************
03/22/2023 18:41:00 - INFO - __main__ -     Best bleu:28.21
03/22/2023 18:41:00 - INFO - __main__ -     ********************
03/22/2023 18:41:11 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='Salesforce/codet5-base', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='Salesforce/codet5-base', model_type='codet5', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='Salesforce/codet5-base', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 18:41:11 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 18:41:20 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 18:41:23 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:07<06:53,  7.52s/it]  4%|▎         | 2/56 [00:14<06:19,  7.04s/it]  5%|▌         | 3/56 [00:22<06:32,  7.42s/it]  7%|▋         | 4/56 [00:31<06:59,  8.07s/it]  9%|▉         | 5/56 [00:41<07:31,  8.86s/it] 11%|█         | 6/56 [00:52<08:03,  9.66s/it] 12%|█▎        | 7/56 [01:04<08:34, 10.51s/it] 14%|█▍        | 8/56 [01:17<09:04, 11.33s/it] 16%|█▌        | 9/56 [01:32<09:33, 12.21s/it] 18%|█▊        | 10/56 [01:47<09:59, 13.04s/it] 20%|█▉        | 11/56 [02:03<10:28, 13.96s/it] 21%|██▏       | 12/56 [02:20<10:55, 14.91s/it] 23%|██▎       | 13/56 [02:38<11:19, 15.81s/it] 25%|██▌       | 14/56 [02:57<11:46, 16.81s/it] 27%|██▋       | 15/56 [03:17<12:10, 17.82s/it] 29%|██▊       | 16/56 [03:38<12:31, 18.78s/it] 30%|███       | 17/56 [04:00<12:50, 19.75s/it] 32%|███▏      | 18/56 [04:23<13:05, 20.68s/it] 34%|███▍      | 19/56 [04:47<13:24, 21.73s/it] 36%|███▌      | 20/56 [05:12<13:42, 22.84s/it] 38%|███▊      | 21/56 [05:39<13:59, 23.97s/it] 39%|███▉      | 22/56 [06:06<14:08, 24.96s/it] 41%|████      | 23/56 [06:35<14:20, 26.08s/it] 43%|████▎     | 24/56 [07:04<14:27, 27.10s/it] 45%|████▍     | 25/56 [07:35<14:35, 28.23s/it] 46%|████▋     | 26/56 [08:07<14:40, 29.37s/it] 48%|████▊     | 27/56 [08:40<14:42, 30.43s/it] 50%|█████     | 28/56 [09:14<14:42, 31.53s/it] 52%|█████▏    | 29/56 [09:49<14:40, 32.61s/it] 54%|█████▎    | 30/56 [10:25<14:33, 33.60s/it] 55%|█████▌    | 31/56 [11:03<14:30, 34.84s/it] 57%|█████▋    | 32/56 [11:41<14:22, 35.93s/it] 59%|█████▉    | 33/56 [12:21<14:11, 37.01s/it] 61%|██████    | 34/56 [13:01<13:54, 37.94s/it] 62%|██████▎   | 35/56 [13:43<13:39, 39.03s/it] 64%|██████▍   | 36/56 [14:25<13:21, 40.06s/it] 66%|██████▌   | 37/56 [15:08<12:57, 40.94s/it] 68%|██████▊   | 38/56 [15:52<12:33, 41.84s/it] 70%|██████▉   | 39/56 [16:37<12:08, 42.85s/it] 71%|███████▏  | 40/56 [17:23<11:38, 43.66s/it] 73%|███████▎  | 41/56 [18:09<11:05, 44.38s/it] 75%|███████▌  | 42/56 [18:56<10:33, 45.28s/it] 77%|███████▋  | 43/56 [19:45<10:03, 46.40s/it] 79%|███████▊  | 44/56 [20:35<09:28, 47.39s/it] 80%|████████  | 45/56 [21:25<08:49, 48.17s/it] 82%|████████▏ | 46/56 [22:17<08:12, 49.29s/it] 84%|████████▍ | 47/56 [23:09<07:31, 50.16s/it] 86%|████████▌ | 48/56 [24:02<06:47, 50.99s/it] 88%|████████▊ | 49/56 [24:57<06:04, 52.07s/it] 89%|████████▉ | 50/56 [25:52<05:19, 53.19s/it] 91%|█████████ | 51/56 [26:48<04:29, 53.99s/it] 93%|█████████▎| 52/56 [27:46<03:40, 55.13s/it] 95%|█████████▍| 53/56 [28:45<02:48, 56.33s/it] 96%|█████████▋| 54/56 [29:46<01:55, 57.67s/it] 98%|█████████▊| 55/56 [30:47<00:58, 58.61s/it]100%|██████████| 56/56 [31:47<00:00, 59.02s/it]100%|██████████| 56/56 [31:47<00:00, 34.06s/it]
03/22/2023 19:13:12 - INFO - __main__ -     bleu-4 = 30.18 
03/22/2023 19:13:12 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 19:13:12 - INFO - __main__ -     ********************
tokenizer.decode(top_preds[0],: def findMinSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE mp [ arr [ j ] ] += 1 NEW_LINE DEDENT DEDENT summin = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT summin = min ( summin , value ) NEW_LINE DEDENT return summin NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMinSum ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def binaryToBinary ( n ) : NEW_LINE INDENT arr = [ 0 ] * 32 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ n % 2 ] = 1 NEW_LINE n //= 2 NEW_LINE DEDENT for i in range ( 32 ) : NEW_LINE INDENT arr [ i ] = n % 2 NEW_LINE DEDENT DEDENT def binaryToDecimal ( n ) : NEW_LINE INDENT arr [ 0 ] = 0 NEW_LINE for i in range ( 1 , int ( math . log2 ( n ) ) + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] | ( 1 << ( int ( math . log2 ( n ) ) - 1 ) ) NEW_LINE DEDENT DEDENT def concat ( a , b , k ) : NEW_LINE INDENT n = binaryToBinary ( a ) NEW_LINE binaryToBinary ( b
tokenizer.decode(top_preds[0],: import math NEW_LINE def convert ( N ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT v . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countNumbers ( A , N , C ) : NEW_LINE INDENT v = convert ( A [ 0 ] ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT v . append ( int ( A [ i ] ) ) NEW_LINE DEDENT return v NEW_LINE DEDENT def countNumbers ( A , B , C ) : NEW_LINE INDENT v = convert ( A [ B ] ) NEW_LINE if ( len ( v ) == 0 ) :
tokenizer.decode(top_preds[0],: def isCorrect ( time ) : NEW_LINE INDENT minute = 0 NEW_LINE hour = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT if ( time [ i ] == ' ? ' ) : NEW_LINE INDENT minute += 1 NEW_LINE DEDENT elif ( time [ i ] == ' ? ' ) : NEW_LINE INDENT hour += 1 NEW_LINE DEDENT elif ( time [ i ] == ' ? ' ) : NEW_LINE INDENT hour += 1 NEW_LINE DEDENT DEDENT return ( hour == minute ) NEW_LINE DEDENT def isValid ( L , R ) : NEW_LINE INDENT hour = 0 NEW_LINE minute = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT hour -= 1 NEW_LINE if ( hour < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findTime
tokenizer.decode(top_preds[0],: def maxIntersections ( n ) : NEW_LINE INDENT cir = n * ( n + 1 ) / 2 NEW_LINE straight = n * ( n + 1 ) / 2 NEW_LINE return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( maxIntersections ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def isUndulating ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def mostSetBitPos ( n ) : NEW_LINE INDENT k = int ( math . log ( n ) / math . log ( 2 ) ) + 1 NEW_LINE return ( n & ( 1 << k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( mostSetBitPos ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def leftRotate ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT DEDENT def leftRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i + d ] NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2
tokenizer.decode(top_preds[0],: def findMissing ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mid = ( i + n ) // 2 NEW_LINE if ( arr [ mid ] == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: MAX_CHAR = 26 NEW_LINE dp = [ [ [ [ - 1 for i in range ( MAX_CHAR ) ] for j in range ( MAX_CHAR ) ] for k in range ( MAX_CHAR ) ] for l in range ( MAX_CHAR ) ] NEW_LINE def lcs ( str1 , str2 , i , j ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT def maxLCS ( str1 , str2 , i , j ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = lcs
tokenizer.decode(top_preds[0],: def findWays ( n ) : NEW_LINE INDENT fac1 = ( n - 1 ) ; NEW_LINE fac2 = ( n - 2 ) ; NEW_LINE ways = fac1 * fac2 ; NEW_LINE print ( ways ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findWays ( n ) ; NEW_LINE
tokenizer.decode(top_preds[0],: import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( n > 1 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return ( isPrime ( n , k ) and isPrime ( n , k - 1 ) ) NEW_LINE DEDENT def isComposite ( n , k ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT if ( value == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE
tokenizer.decode(top_preds[0],: import math NEW_LINE def areaOfSector ( a ) : NEW_LINE INDENT area = ( a * a ) NEW_LINE return area NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area ▁ of ▁ the ▁ Circular ▁ Sector ▁ is ▁ : ▁ " , areaOfSector ( a ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def minimumSwaps ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE swaps = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == ' X ' ) : NEW_LINE INDENT swaps += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i ] == ' X ' ) : NEW_LINE INDENT swaps += 1 NEW_LINE DEDENT DEDENT DEDENT print ( swaps ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE minimumSwaps ( N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def lis ( arr , n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res . append ( arr [ j ] ) NEW_LINE DEDENT DEDENT res = max ( res , res [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT res . append ( arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findLIS ( arr , n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range (
tokenizer.decode(top_preds[0],: def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def sortArray ( arr , n , a , b ) : NEW_LINE INDENT start = a NEW_LINE end = b NEW_LINE arr . sort ( ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sortArray ( arr , n , a , b ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maxSquare ( a , b , c ) : NEW_LINE INDENT return a * b + c * c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxSquare ( a , b , c ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: n = 4 NEW_LINE m = 4 NEW_LINE def countSets ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == '1' ) : NEW_LINE INDENT ans += n * m NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE print ( countSets ( mat ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def pathCountDPRecDP ( m , n , k ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return pathCountDPRecDP ( m - 1 , n - 1 , k ) NEW_LINE DEDENT return pathCountDPRecDP ( m - 1 , n - 1 , k - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE
tokenizer.decode(top_preds[0],: def addNoCarry ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE y = y >> 1 NEW_LINE carry = carry ^ x NEW_LINE DEDENT sum = 0 NEW_LINE while ( carry ) : NEW_LINE INDENT sum += carry NEW_LINE carry = carry >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE print ( addNoCarry ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def precomputeXOR ( L , R ) : NEW_LINE INDENT prefixXOR = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT DEDENT return prefixXOR NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 5 NEW_LINE R = 10 NEW_LINE print ( precomputeXOR ( L , R ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def reverseArray ( arr , s , e ) : NEW_LINE INDENT for i in range ( s , e + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT def generateRotations ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateRotations ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maximumABs ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' A ' and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( s [ i ] == ' B ' and s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GeeksForGeeks " NEW_LINE print ( maximumABs ( s ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def longestSubsequence ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for y in range ( n ) : NEW_LINE INDENT arr [ x ] = arr [ y ] NEW_LINE x += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE longestSubsequence ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countSubsets ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countSubsets ( arr , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( K * arr [ j ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairs ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def possible ( A , B , n , x , y ) : NEW_LINE INDENT if ( n < x or n > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT A . sort ( ) ; NEW_LINE B . sort ( ) ; NEW_LINE if ( A [ n - 1 ] < B [ n - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT A . sort ( ) ; NEW_LINE B . sort ( ) ; NEW_LINE if ( possible ( A , B , n , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def minimumOperations ( arr , N ) : NEW_LINE INDENT prefix_sum = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i ] + arr [ i ] NEW_LINE DEDENT max_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i ] + arr [ i ] NEW_LINE DEDENT max_sum = max ( max_sum , prefix_sum [ N - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( prefix_sum [ i ] == prefix_sum [ i + 1 ] ) : NEW_LINE INDENT count_groups += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , prefix_sum [ i ] ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def rightShifts ( A , N ) : NEW_LINE INDENT shifts = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT shifts += 1 NEW_LINE DEDENT DEDENT print ( shifts ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE rightShifts ( A , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: MAX = 26 NEW_LINE def smallestString ( s ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] = mp . get ( ord ( s [ i ] ) - ord ( ' a ' ) , 0 ) + 1 NEW_LINE DEDENT processed = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_
tokenizer.decode(top_preds[0],: import numpy as np NEW_LINE def check ( sm1 , sm2 , sm3 , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( sm1 == - 1 or sm2 == - 1 or sm3 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( sm1 [ i ] + sm2 [ j ] == sm3 [ j ] + sm1 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def partition ( arr , n ) : NEW_LINE INDENT sm1 = np . zeros ( ( n + 1 , n + 1 ) ) NEW_LINE sm2 = np . zeros ( ( n + 1 , n
tokenizer.decode(top_preds[0],: def maxSubArraySum ( a , n , k ) : NEW_LINE INDENT maxSubArraySum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxSubArraySum += a [ i ] NEW_LINE DEDENT return maxSubArraySum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxSubArraySum ( a , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def printPalindrome ( S ) : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for ch in S : NEW_LINE INDENT Hash [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for ch in range ( 26 ) : NEW_LINE INDENT if ( Hash [ ch ] == 2 ) : NEW_LINE INDENT for i in range ( ord ( ch ) - ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT st = set ( ) NEW_LINE for j in range ( ord ( ch ) - ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: from collections import defaultdict NEW_LINE def encrypt ( s , x ) : NEW_LINE INDENT n = len ( s ) NEW_LINE x = x % 26 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE x = 2 NEW_LINE print ( encrypt ( s , x ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countWords ( str ) : NEW_LINE INDENT a = str . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE print ( countWords ( str ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 2 * r * r NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( circlearea ( r ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def findSubset ( N ) : NEW_LINE INDENT count = [ 0 for i in range ( 8 ) ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT A = [ 0 for i in range ( 8 ) ] NEW_LINE B = [ 0 for i in range ( 8 ) ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT A [ i ] = i NEW_LINE B [ i ] = i NEW_LINE DEDENT for i in range ( 8 ) : NEW_LINE INDENT if ( count [ i ] == 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT elif ( count [ i ] == 2 ) : NEW_LINE INDENT B [ i ] = B [ i - 1 ] NEW_LINE DEDENT elif ( count [ i ] == 3 ) : NEW_LINE INDENT B
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def getProduct ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT prod *= ( arr [ i ] * arr [ j ] ) NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getProduct ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE isPossible ( x , y ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def checkPoint ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT if ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print (
tokenizer.decode(top_preds[0],: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum - arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , sum - arr [ 0 ] ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT ans = max ( ans , sum - arr [ 1 ] ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT ans = max ( ans , sum
tokenizer.decode(top_preds[0],: import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT if ( sum <= n ) : NEW_LINE INDENT print
tokenizer.decode(top_preds[0],: import math NEW_LINE def compare ( x , y ) : NEW_LINE INDENT x = x * x + y * y NEW_LINE y = y * y + x NEW_LINE print ( " x ^ ▁ y ^ ▁ x ▁ = ▁ " , x , " ^ ▁ " , y , " ^ ▁ " , x , " ^ ▁ y ^ ▁ x ▁ = ▁ " , y , " ^ ▁ " , y , " ^ ▁ " , x , " ^ ▁ " , y , " ^ ▁ x ▁ ^ ▁ y ▁ = ▁ " , y , " ^ ▁ " , x , " ^ ▁ " , y , " ^ �
tokenizer.decode(top_preds[0],: def printResult ( arr , n , queries ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( queries ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ [ 1 , 2 ] , [ 3 , 4 ] , [
tokenizer.decode(top_preds[0],: def arePermutations ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mul1 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += arr1 [ i ] NEW_LINE mul1 += arr2 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += arr2 [ i ] NEW_LINE mul2 += arr2 [ i ] NEW_LINE DEDENT if ( sum1 == sum2 and mul1 == mul2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 2 , 3 , 5 ] NEW_LINE
tokenizer.decode(top_preds[0],: def average ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( " Average ▁ of ▁ first " , n , " odd ▁ numbers ▁ is ▁ " , average ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def countPairs ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE freq = [ 0 ] * ( max_element + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , max_element + 1 ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE count
tokenizer.decode(top_preds[0],: def convert ( m , n ) : NEW_LINE INDENT if ( m < n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " + 1" ) NEW_LINE return NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " - 2" ) NEW_LINE return NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + ( num % 10 ) NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 12345 NEW_LINE print ( reverseDigits ( num ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def areSame ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( len ( arr1 ) ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT countP = [ 0 ] * 26 NEW_LINE countTW = [ 0 ] * 26 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE
tokenizer.decode(top_preds[0],: def countDiagonal ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countDiagonal ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def kthSubString ( s , k ) : NEW_LINE INDENT total = len ( s ) NEW_LINE if ( k > total ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( k > total ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT sum += s [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( sum % k == 0 ) : NEW_LINE INDENT print ( s [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __
tokenizer.decode(top_preds[0],: def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def compare ( A , B ) : NEW_LINE INDENT AB = str ( A ) NEW_LINE BA = str ( B ) NEW_LINE if ( AB < BA ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁
tokenizer.decode(top_preds[0],: def minDiff ( arr , n ) : NEW_LINE INDENT minimum = arr [ 0 ] NEW_LINE maximum = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT return minimum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minDiff ( arr , n ) ) NEW_LINE
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START EVAL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: Salesforce/codet5-base
Model type: codet5
Experiment name: codet5_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
03/22/2023 19:13:16 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='Salesforce/codet5-base', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='Salesforce/codet5-base', model_type='codet5', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='Salesforce/codet5-base', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 19:13:17 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 19:13:25 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 19:13:28 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:07<07:07,  7.78s/it]  4%|▎         | 2/56 [00:14<06:23,  7.11s/it]  5%|▌         | 3/56 [00:22<06:34,  7.44s/it]  7%|▋         | 4/56 [00:31<06:57,  8.02s/it]  9%|▉         | 5/56 [00:40<07:21,  8.65s/it] 11%|█         | 6/56 [00:51<07:46,  9.32s/it] 12%|█▎        | 7/56 [01:03<08:23, 10.28s/it] 14%|█▍        | 8/56 [01:16<08:55, 11.15s/it] 16%|█▌        | 9/56 [01:30<09:27, 12.08s/it] 18%|█▊        | 10/56 [01:46<09:58, 13.01s/it] 20%|█▉        | 11/56 [02:01<10:26, 13.91s/it] 21%|██▏       | 12/56 [02:18<10:52, 14.82s/it] 23%|██▎       | 13/56 [02:37<11:21, 15.85s/it] 25%|██▌       | 14/56 [02:56<11:48, 16.87s/it] 27%|██▋       | 15/56 [03:16<12:13, 17.90s/it] 29%|██▊       | 16/56 [03:37<12:34, 18.87s/it] 30%|███       | 17/56 [04:00<13:00, 20.01s/it] 32%|███▏      | 18/56 [04:23<13:16, 20.96s/it] 34%|███▍      | 19/56 [04:48<13:37, 22.11s/it] 36%|███▌      | 20/56 [05:14<13:54, 23.18s/it] 38%|███▊      | 21/56 [05:41<14:12, 24.36s/it] 39%|███▉      | 22/56 [06:08<14:20, 25.30s/it] 41%|████      | 23/56 [06:37<14:29, 26.34s/it] 43%|████▎     | 24/56 [07:07<14:38, 27.44s/it] 45%|████▍     | 25/56 [07:38<14:43, 28.49s/it] 46%|████▋     | 26/56 [08:10<14:45, 29.52s/it] 48%|████▊     | 27/56 [08:43<14:45, 30.53s/it] 50%|█████     | 28/56 [09:17<14:45, 31.62s/it] 52%|█████▏    | 29/56 [09:52<14:46, 32.82s/it] 54%|█████▎    | 30/56 [10:29<14:39, 33.81s/it] 55%|█████▌    | 31/56 [11:07<14:39, 35.20s/it] 57%|█████▋    | 32/56 [11:45<14:27, 36.16s/it] 59%|█████▉    | 33/56 [12:25<14:13, 37.12s/it] 61%|██████    | 34/56 [13:05<13:57, 38.08s/it] 62%|██████▎   | 35/56 [13:47<13:42, 39.19s/it] 64%|██████▍   | 36/56 [14:29<13:24, 40.21s/it] 66%|██████▌   | 37/56 [15:13<13:01, 41.13s/it] 68%|██████▊   | 38/56 [15:57<12:35, 41.96s/it] 70%|██████▉   | 39/56 [16:42<12:10, 42.99s/it] 71%|███████▏  | 40/56 [17:28<11:40, 43.79s/it] 73%|███████▎  | 41/56 [18:14<11:08, 44.57s/it] 75%|███████▌  | 42/56 [19:02<10:37, 45.55s/it] 77%|███████▋  | 43/56 [19:51<10:06, 46.68s/it] 79%|███████▊  | 44/56 [20:41<09:30, 47.55s/it] 80%|████████  | 45/56 [21:31<08:53, 48.47s/it] 82%|████████▏ | 46/56 [22:23<08:13, 49.38s/it] 84%|████████▍ | 47/56 [23:15<07:32, 50.28s/it] 86%|████████▌ | 48/56 [24:08<06:48, 51.12s/it] 88%|████████▊ | 49/56 [25:03<06:04, 52.14s/it] 89%|████████▉ | 50/56 [25:59<05:19, 53.22s/it] 91%|█████████ | 51/56 [26:55<04:30, 54.10s/it] 93%|█████████▎| 52/56 [27:52<03:40, 55.04s/it] 95%|█████████▍| 53/56 [28:51<02:48, 56.24s/it] 96%|█████████▋| 54/56 [29:51<01:54, 57.32s/it] 98%|█████████▊| 55/56 [30:51<00:58, 58.25s/it]100%|██████████| 56/56 [31:52<00:00, 58.88s/it]100%|██████████| 56/56 [31:52<00:00, 34.15s/it]
03/22/2023 19:45:21 - INFO - __main__ -     bleu-4 = 30.18 
03/22/2023 19:45:21 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 19:45:21 - INFO - __main__ -     ********************
tokenizer.decode(top_preds[0],: def findMinSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE mp [ arr [ j ] ] += 1 NEW_LINE DEDENT DEDENT summin = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT summin = min ( summin , value ) NEW_LINE DEDENT return summin NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMinSum ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def binaryToBinary ( n ) : NEW_LINE INDENT arr = [ 0 ] * 32 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ n % 2 ] = 1 NEW_LINE n //= 2 NEW_LINE DEDENT for i in range ( 32 ) : NEW_LINE INDENT arr [ i ] = n % 2 NEW_LINE DEDENT DEDENT def binaryToDecimal ( n ) : NEW_LINE INDENT arr [ 0 ] = 0 NEW_LINE for i in range ( 1 , int ( math . log2 ( n ) ) + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] | ( 1 << ( int ( math . log2 ( n ) ) - 1 ) ) NEW_LINE DEDENT DEDENT def concat ( a , b , k ) : NEW_LINE INDENT n = binaryToBinary ( a ) NEW_LINE binaryToBinary ( b
tokenizer.decode(top_preds[0],: import math NEW_LINE def convert ( N ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT v . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countNumbers ( A , N , C ) : NEW_LINE INDENT v = convert ( A [ 0 ] ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT v . append ( int ( A [ i ] ) ) NEW_LINE DEDENT return v NEW_LINE DEDENT def countNumbers ( A , B , C ) : NEW_LINE INDENT v = convert ( A [ B ] ) NEW_LINE if ( len ( v ) == 0 ) :
tokenizer.decode(top_preds[0],: def isCorrect ( time ) : NEW_LINE INDENT minute = 0 NEW_LINE hour = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT if ( time [ i ] == ' ? ' ) : NEW_LINE INDENT minute += 1 NEW_LINE DEDENT elif ( time [ i ] == ' ? ' ) : NEW_LINE INDENT hour += 1 NEW_LINE DEDENT elif ( time [ i ] == ' ? ' ) : NEW_LINE INDENT hour += 1 NEW_LINE DEDENT DEDENT return ( hour == minute ) NEW_LINE DEDENT def isValid ( L , R ) : NEW_LINE INDENT hour = 0 NEW_LINE minute = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT hour -= 1 NEW_LINE if ( hour < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findTime
tokenizer.decode(top_preds[0],: def maxIntersections ( n ) : NEW_LINE INDENT cir = n * ( n + 1 ) / 2 NEW_LINE straight = n * ( n + 1 ) / 2 NEW_LINE return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( maxIntersections ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def isUndulating ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def mostSetBitPos ( n ) : NEW_LINE INDENT k = int ( math . log ( n ) / math . log ( 2 ) ) + 1 NEW_LINE return ( n & ( 1 << k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( mostSetBitPos ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def leftRotate ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT DEDENT def leftRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i + d ] NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2
tokenizer.decode(top_preds[0],: def findMissing ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mid = ( i + n ) // 2 NEW_LINE if ( arr [ mid ] == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: MAX_CHAR = 26 NEW_LINE dp = [ [ [ [ - 1 for i in range ( MAX_CHAR ) ] for j in range ( MAX_CHAR ) ] for k in range ( MAX_CHAR ) ] for l in range ( MAX_CHAR ) ] NEW_LINE def lcs ( str1 , str2 , i , j ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT def maxLCS ( str1 , str2 , i , j ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = lcs
tokenizer.decode(top_preds[0],: def findWays ( n ) : NEW_LINE INDENT fac1 = ( n - 1 ) ; NEW_LINE fac2 = ( n - 2 ) ; NEW_LINE ways = fac1 * fac2 ; NEW_LINE print ( ways ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findWays ( n ) ; NEW_LINE
tokenizer.decode(top_preds[0],: import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( n > 1 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return ( isPrime ( n , k ) and isPrime ( n , k - 1 ) ) NEW_LINE DEDENT def isComposite ( n , k ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ i ] & A [ j ] ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT if ( value == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE
tokenizer.decode(top_preds[0],: import math NEW_LINE def areaOfSector ( a ) : NEW_LINE INDENT area = ( a * a ) NEW_LINE return area NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area ▁ of ▁ the ▁ Circular ▁ Sector ▁ is ▁ : ▁ " , areaOfSector ( a ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def minimumSwaps ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE swaps = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == ' X ' ) : NEW_LINE INDENT swaps += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i ] == ' X ' ) : NEW_LINE INDENT swaps += 1 NEW_LINE DEDENT DEDENT DEDENT print ( swaps ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE minimumSwaps ( N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def lis ( arr , n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT res . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res . append ( arr [ j ] ) NEW_LINE DEDENT DEDENT res = max ( res , res [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT res . append ( arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findLIS ( arr , n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range (
tokenizer.decode(top_preds[0],: def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def sortArray ( arr , n , a , b ) : NEW_LINE INDENT start = a NEW_LINE end = b NEW_LINE arr . sort ( ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sortArray ( arr , n , a , b ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maxSquare ( a , b , c ) : NEW_LINE INDENT return a * b + c * c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxSquare ( a , b , c ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: n = 4 NEW_LINE m = 4 NEW_LINE def countSets ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == '1' ) : NEW_LINE INDENT ans += n * m NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE print ( countSets ( mat ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def pathCountDPRecDP ( m , n , k ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return pathCountDPRecDP ( m - 1 , n - 1 , k ) NEW_LINE DEDENT return pathCountDPRecDP ( m - 1 , n - 1 , k - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE
tokenizer.decode(top_preds[0],: def addNoCarry ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE y = y >> 1 NEW_LINE carry = carry ^ x NEW_LINE DEDENT sum = 0 NEW_LINE while ( carry ) : NEW_LINE INDENT sum += carry NEW_LINE carry = carry >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE print ( addNoCarry ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def precomputeXOR ( L , R ) : NEW_LINE INDENT prefixXOR = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT prefixXOR ^= i NEW_LINE DEDENT DEDENT return prefixXOR NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 5 NEW_LINE R = 10 NEW_LINE print ( precomputeXOR ( L , R ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def reverseArray ( arr , s , e ) : NEW_LINE INDENT for i in range ( s , e + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT def generateRotations ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateRotations ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def maximumABs ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' A ' and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( s [ i ] == ' B ' and s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GeeksForGeeks " NEW_LINE print ( maximumABs ( s ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def longestSubsequence ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for y in range ( n ) : NEW_LINE INDENT arr [ x ] = arr [ y ] NEW_LINE x += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE longestSubsequence ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countSubsets ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countSubsets ( arr , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( K * arr [ j ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairs ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def possible ( A , B , n , x , y ) : NEW_LINE INDENT if ( n < x or n > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT A . sort ( ) ; NEW_LINE B . sort ( ) ; NEW_LINE if ( A [ n - 1 ] < B [ n - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT A . sort ( ) ; NEW_LINE B . sort ( ) ; NEW_LINE if ( possible ( A , B , n , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def minimumOperations ( arr , N ) : NEW_LINE INDENT prefix_sum = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i ] + arr [ i ] NEW_LINE DEDENT max_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i ] + arr [ i ] NEW_LINE DEDENT max_sum = max ( max_sum , prefix_sum [ N - 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( prefix_sum [ i ] == prefix_sum [ i + 1 ] ) : NEW_LINE INDENT count_groups += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , prefix_sum [ i ] ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def rightShifts ( A , N ) : NEW_LINE INDENT shifts = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT shifts += 1 NEW_LINE DEDENT DEDENT print ( shifts ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE rightShifts ( A , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: MAX = 26 NEW_LINE def smallestString ( s ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] = mp . get ( ord ( s [ i ] ) - ord ( ' a ' ) , 0 ) + 1 NEW_LINE DEDENT processed = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] != - 1 ) : NEW_
tokenizer.decode(top_preds[0],: import numpy as np NEW_LINE def check ( sm1 , sm2 , sm3 , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( sm1 == - 1 or sm2 == - 1 or sm3 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( sm1 [ i ] + sm2 [ j ] == sm3 [ j ] + sm1 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def partition ( arr , n ) : NEW_LINE INDENT sm1 = np . zeros ( ( n + 1 , n + 1 ) ) NEW_LINE sm2 = np . zeros ( ( n + 1 , n
tokenizer.decode(top_preds[0],: def maxSubArraySum ( a , n , k ) : NEW_LINE INDENT maxSubArraySum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxSubArraySum += a [ i ] NEW_LINE DEDENT return maxSubArraySum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxSubArraySum ( a , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def printPalindrome ( S ) : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for ch in S : NEW_LINE INDENT Hash [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for ch in range ( 26 ) : NEW_LINE INDENT if ( Hash [ ch ] == 2 ) : NEW_LINE INDENT for i in range ( ord ( ch ) - ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT st = set ( ) NEW_LINE for j in range ( ord ( ch ) - ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: from collections import defaultdict NEW_LINE def encrypt ( s , x ) : NEW_LINE INDENT n = len ( s ) NEW_LINE x = x % 26 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE x = 2 NEW_LINE print ( encrypt ( s , x ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def countWords ( str ) : NEW_LINE INDENT a = str . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE print ( countWords ( str ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 2 * r * r NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( circlearea ( r ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def findSubset ( N ) : NEW_LINE INDENT count = [ 0 for i in range ( 8 ) ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT A = [ 0 for i in range ( 8 ) ] NEW_LINE B = [ 0 for i in range ( 8 ) ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT A [ i ] = i NEW_LINE B [ i ] = i NEW_LINE DEDENT for i in range ( 8 ) : NEW_LINE INDENT if ( count [ i ] == 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 1 ] NEW_LINE DEDENT elif ( count [ i ] == 2 ) : NEW_LINE INDENT B [ i ] = B [ i - 1 ] NEW_LINE DEDENT elif ( count [ i ] == 3 ) : NEW_LINE INDENT B
tokenizer.decode(top_preds[0],: from math import sqrt NEW_LINE def getProduct ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT prod *= ( arr [ i ] * arr [ j ] ) NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getProduct ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def isPossible ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE isPossible ( x , y ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def checkPoint ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT if ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 < x2 and y1 < y2 ) : NEW_LINE INDENT print (
tokenizer.decode(top_preds[0],: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum - arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , sum - arr [ 0 ] ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT ans = max ( ans , sum - arr [ 1 ] ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT ans = max ( ans , sum
tokenizer.decode(top_preds[0],: import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT if ( sum <= n ) : NEW_LINE INDENT print
tokenizer.decode(top_preds[0],: import math NEW_LINE def compare ( x , y ) : NEW_LINE INDENT x = x * x + y * y NEW_LINE y = y * y + x NEW_LINE print ( " x ^ ▁ y ^ ▁ x ▁ = ▁ " , x , " ^ ▁ " , y , " ^ ▁ " , x , " ^ ▁ y ^ ▁ x ▁ = ▁ " , y , " ^ ▁ " , y , " ^ ▁ " , x , " ^ ▁ " , y , " ^ ▁ x ▁ ^ ▁ y ▁ = ▁ " , y , " ^ ▁ " , x , " ^ ▁ " , y , " ^ �
tokenizer.decode(top_preds[0],: def printResult ( arr , n , queries ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( queries ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ [ 1 , 2 ] , [ 3 , 4 ] , [
tokenizer.decode(top_preds[0],: def arePermutations ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mul1 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += arr1 [ i ] NEW_LINE mul1 += arr2 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += arr2 [ i ] NEW_LINE mul2 += arr2 [ i ] NEW_LINE DEDENT if ( sum1 == sum2 and mul1 == mul2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 2 , 3 , 5 ] NEW_LINE
tokenizer.decode(top_preds[0],: def average ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( " Average ▁ of ▁ first " , n , " odd ▁ numbers ▁ is ▁ " , average ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def countPairs ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE freq = [ 0 ] * ( max_element + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , max_element + 1 ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE count
tokenizer.decode(top_preds[0],: def convert ( m , n ) : NEW_LINE INDENT if ( m < n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " + 1" ) NEW_LINE return NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " - 2" ) NEW_LINE return NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT
tokenizer.decode(top_preds[0],: import math NEW_LINE def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + ( num % 10 ) NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 12345 NEW_LINE print ( reverseDigits ( num ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0],: def areSame ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( len ( arr1 ) ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT countP = [ 0 ] * 26 NEW_LINE countTW = [ 0 ] * 26 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE
tokenizer.decode(top_preds[0],: def countDiagonal ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countDiagonal ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0],: def kthSubString ( s , k ) : NEW_LINE INDENT total = len ( s ) NEW_LINE if ( k > total ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( k > total ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT sum += s [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( sum % k == 0 ) : NEW_LINE INDENT print ( s [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __
tokenizer.decode(top_preds[0],: def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def compare ( A , B ) : NEW_LINE INDENT AB = str ( A ) NEW_LINE BA = str ( B ) NEW_LINE if ( AB < BA ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁
tokenizer.decode(top_preds[0],: def minDiff ( arr , n ) : NEW_LINE INDENT minimum = arr [ 0 ] NEW_LINE maximum = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT return minimum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minDiff ( arr , n ) ) NEW_LINE
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
