@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
probing_case 도입


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ RUNNING SCRIPT: job_n_NoAug_py_unixcoder_syn.sh

Wed Mar 22 17:22:53 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 465.19.01    Driver Version: 465.19.01    CUDA Version: 11.3     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  On   | 00000000:81:00.0 Off |                  N/A |
| 46%   48C    P5    83W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2022 NVIDIA Corporation
Built on Wed_Jun__8_16:49:14_PDT_2022
Cuda compilation tools, release 11.7, V11.7.99
Build cuda_11.7.r11.7/compiler.31442593_0
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START TRAIN @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: microsoft/unixcoder-base-nine
Model type: roberta
Experiment name: unixcoder_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
/home/ysnamgoong42/ws/XLCoST/code
03/22/2023 17:22:56 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='microsoft/unixcoder-base-nine', dev_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/val-Python-desc-tok.py', do_eval=True, do_lower_case=False, do_test=False, do_train=True, eval_batch_size=16, eval_steps=2500, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path=None, local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='microsoft/unixcoder-base-nine', model_type='roberta', no_cuda=False, num_train_epochs=10.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename=None, tokenizer_name='microsoft/unixcoder-base-nine', train_batch_size=16, train_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/train-Python-desc-tok.py', train_steps=5000, warmup_steps=0, weight_decay=0.0)
03/22/2023 17:22:57 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 17:23:09 - INFO - __main__ -   *** Example ***
03/22/2023 17:23:09 - INFO - __main__ -   idx: 0
03/22/2023 17:23:09 - INFO - __main__ -   source_tokens: ['<s>', 'Maximum', '_Prefix', '_Sum', '_possible', '_by', '_merging', '_two', '_given', '_arrays', '_|', '_Python', '3', '_implementation', '_of', '_the', '_above', '_approach', '_;', '_Sto', 'res', '_the', '_maximum', '_prefix', '_sum', '_of', '_the', '_array', '_A', '_[', '_]', '_;', '_Traverse', '_the', '_array', '_A', '_[', '_]', '_;', '_Sto', 'res', '_the', '_maximum', '_prefix', '_sum', '_of', '_the', '_array', '_B', '_[', '_]', '_;', '_Traverse', '_the', '_array', '_B', '_[', '_]', '_;', '_Driver', '_code', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   source_ids: 0 10878 22921 15571 5232 1243 28728 3647 2076 7972 649 7853 137 6490 595 448 6258 28276 2476 7896 587 448 6098 3603 3863 595 448 866 553 626 2406 2476 39368 448 866 553 626 2406 2476 7896 587 448 6098 3603 3863 595 448 866 719 626 2406 2476 39368 448 866 719 626 2406 2476 19262 1717 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   target_tokens: ['<s>', 'def', '_max', 'Pres', 'um', '_(', '_a', '_,', '_b', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_X', '_=', '_max', '_(', '_a', '_[', '_0', '_]', '_,', '_0', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_1', '_,', '_len', '_(', '_a', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_a', '_[', '_i', '_]', '_+=', '_a', '_[', '_i', '_-', '_1', '_]', '_NEW', '_', 'LINE', '_X', '_=', '_max', '_(', '_X', '_,', '_a', '_[', '_i', '_]', '_)', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_Y', '_=', '_max', '_(', '_b', '_[', '_0', '_]', '_,', '_0', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_1', '_,', '_len', '_(', '_b', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_b', '_[', '_i', '_]', '_+=', '_b', '_[', '_i', '_-', '_1', '_]', '_NEW', '_', 'LINE', '_Y', '_=', '_max', '_(', '_Y', '_,', '_b', '_[', '_i', '_]', '_)', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_return', '_X', '_+', '_Y', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_A', '_=', '_[', '_2', '_,', '_-', '_1', '_,', '_4', '_,', '_-', '_5', '_]', '_NEW', '_', 'LINE', '_B', '_=', '_[', '_4', '_,', '_-', '_3', '_,', '_12', '_,', '_4', '_,', '_-', '_3', '_]', '_NEW', '_', 'LINE', '_print', '_(', '_max', 'Pres', 'um', '_(', '_A', '_,', '_B', '_)', '_)', '_NEW', '_', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   target_ids: 0 729 1621 13997 474 400 434 2019 442 743 545 20786 181 4090 17453 1718 1352 385 1621 400 434 626 461 2406 2019 461 743 20786 181 4090 563 548 488 1780 400 524 2019 1015 400 434 743 743 545 20786 181 4090 17453 1718 434 626 548 2406 1054 434 626 548 581 524 2406 20786 181 4090 1352 385 1621 400 1352 2019 434 626 548 2406 743 20786 181 4090 614 1173 1718 2644 385 1621 400 442 626 461 2406 2019 461 743 20786 181 4090 563 548 488 1780 400 524 2019 1015 400 442 743 743 545 20786 181 4090 17453 1718 442 626 548 2406 1054 442 626 548 581 524 2406 20786 181 4090 2644 385 1621 400 2644 2019 442 626 548 2406 743 20786 181 4090 614 1173 1718 483 1352 513 2644 20786 181 4090 614 1173 1718 553 385 626 688 2019 581 524 2019 1080 2019 581 1365 2406 20786 181 4090 719 385 626 1080 2019 581 995 2019 3294 2019 1080 2019 581 995 2406 20786 181 4090 1644 400 1621 13997 474 400 553 2019 719 743 743 20786 181 2
03/22/2023 17:23:09 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   *** Example ***
03/22/2023 17:23:09 - INFO - __main__ -   idx: 1
03/22/2023 17:23:09 - INFO - __main__ -   source_tokens: ['<s>', 'Check', '_if', '_a', '_number', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_positive', '_perfect', '_cub', 'es', '_|', '_Python', '3', '_program', '_for', '_the', '_above', '_approach', '_;', '_Function', '_to', '_check', '_if', '_N', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_perfect', '_cub', 'es', '_or', '_not', '_;', '_If', '_it', '_is', '_same', '_return', '_true', '_;', '_;', '_If', '_the', '_curr', '_smaller', '_than', '_n', '_increment', '_the', '_lo', '_;', '_If', '_the', '_curr', '_is', '_greater', '_than', '_curr', '_decrement', '_the', '_hi', '_;', '_Driver', '_Code', '_;', '_Function', '_call', '_to', '_check', '_if', '_N', '_can', '_be', '_represented', '_as', '_sum', '_of', '_two', '_perfect', '_cub', 'es', '_or', '_not', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   source_ids: 0 1749 462 434 1635 1347 661 15879 880 3863 595 3647 9971 27641 33581 482 649 7853 137 6016 563 448 6258 28276 2476 4629 508 1382 462 591 1347 661 15879 880 3863 595 3647 27641 33581 482 872 800 2476 1359 835 555 2641 483 769 2476 2476 1359 448 7523 12370 2895 416 9397 448 1663 2476 1359 448 7523 555 8954 2895 7523 27547 448 11378 2476 19262 4489 2476 4629 1614 508 1382 462 591 1347 661 15879 880 3863 595 3647 27641 33581 482 872 800 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   target_tokens: ['<s>', 'import', '_math', '_NEW', '_', 'LINE', '_def', '_sum', 'Of', 'Two', 'Cub', 'es', '_(', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_lo', '_=', '_1', '_NEW', '_', 'LINE', '_hi', '_=', '_round', '_(', '_math', '_.', '_pow', '_(', '_n', '_,', '_1', '_/', '_3', '_)', '_)', '_NEW', '_', 'LINE', '_while', '_(', '_lo', '_<=', '_hi', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_curr', '_=', '_(', '_lo', '_*', '_lo', '_*', '_lo', '_+', '_hi', '_*', '_hi', '_*', '_hi', '_)', '_NEW', '_', 'LINE', '_if', '_(', '_curr', '_==', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_return', '_True', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_if', '_(', '_curr', '_<', '_n', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_lo', '_+=', '_1', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_else', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_hi', '_-=', '_1', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_D', 'ED', 'ENT', '_return', '_False', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_N', '_=', '_28', '_NEW', '_', 'LINE', '_if', '_(', '_sum', 'Of', 'Two', 'Cub', 'es', '_(', '_N', '_)', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_print', '_(', '_"', '_True', '_"', '_)', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_else', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_print', '_(', '_"', '_False', '_"', '_)', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   target_ids: 0 4308 7553 20786 181 4090 1551 3863 1307 8705 28640 482 400 416 743 545 20786 181 4090 17453 1718 1663 385 524 20786 181 4090 11378 385 7004 400 7553 746 11854 400 416 2019 524 1017 995 743 743 20786 181 4090 1745 400 1663 1826 11378 743 545 20786 181 4090 17453 1718 7523 385 400 1663 426 1663 426 1663 513 11378 426 11378 426 11378 743 20786 181 4090 462 400 7523 550 416 743 545 20786 181 4090 17453 1718 483 2998 20786 181 4090 614 1173 1718 462 400 7523 517 416 743 545 20786 181 4090 17453 1718 1663 1054 524 20786 181 4090 614 1173 1718 669 545 20786 181 4090 17453 1718 11378 3127 524 20786 181 4090 614 1173 1718 614 1173 1718 483 3378 20786 181 4090 614 1173 1718 591 385 9266 20786 181 4090 462 400 3863 1307 8705 28640 482 400 591 743 743 545 20786 181 4090 17453 1718 1644 400 437 2998 437 743 20786 181 4090 614 1173 1718 669 545 20786 181 4090 17453 1718 1644 400 437 3378 437 743 20786 181 4090 614 1173 1718 2 1 1
03/22/2023 17:23:09 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
03/22/2023 17:23:09 - INFO - __main__ -   *** Example ***
03/22/2023 17:23:09 - INFO - __main__ -   idx: 2
03/22/2023 17:23:09 - INFO - __main__ -   source_tokens: ['<s>', 'Generate', '_an', '_N', '_|', '_Python', '3', '_program', '_for', '_the', '_above', '_approach', '_;', '_Function', '_to', '_generate', '_all', '_prime', '_numbers', '_u', 'pto', '_10', '_^', '_6', '_;', '_Initialize', '_s', 'ieve', '_[', '_]', '_as', '_1', '_;', '_Iterate', '_over', '_the', '_range', '_[', '_2', '_,', '_N', '_]', '_;', '_If', '_current', '_element', '_is', '_non', '_-', '_prime', '_;', '_Make', '_all', '_multiple', 's', '_of', '_i', '_as', '_0', '_;', '_Function', '_to', '_construct', '_an', '_array', '_A', '_[', '_]', '_satisfy', 'ing', '_the', '_given', '_conditions', '_;', '_Sto', 'res', '_the', '_result', 'ant', '_array', '_;', '_Sto', 'res', '_all', '_prime', '_numbers', '_;', '_S', 'ieve', '_of', '_E', 'ra', 'st', 'ost', 'h', 'enes', '_;', '_Append', '_the', '_integer', '_i', '_if', '_it', '_is', '_a', '_prime', '_;', '_Indicates', '_current', '_position', '_in', '_list', '_of', '_prime', '_numbers', '_;', '_Traverse', '_the', '_array', '_arr', '_[', '_]', '_;', '_If', '_already', '_filled', '_with', '_another', '_prime', '_number', '_;', '_If', '_A', '_[', '_i', '_]', '_is', '_not', '_filled', '_but', '_A', '_[', '_ind', '_]', '_is', '_filled', '_;', '_Store', '_A', '_[', '_i', '_]', '_=', '_A', '_[', '_ind', '_]', '_;', '_If', '_none', '_of', '_them', '_were', '_filled', '_;', '_To', '_make', '_sure', '_A', '_[', '_i', '_]', '_does', '_not', '_affect', '_other', '_values', '_,', '_store', '_next', '_prime', '_number', '_;', '_Print', '_the', '_result', 'ant', '_array', '_;', '_Driver', '_Code', '_;', '_Function', '_Call', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   source_ids: 0 7350 817 591 649 7853 137 6016 563 448 6258 28276 2476 4629 508 4666 1345 24029 7918 632 30629 1865 3855 1774 2476 6196 431 12730 626 2406 880 524 2476 21519 2681 448 1780 626 688 2019 591 2406 2476 1359 1434 1398 555 2514 581 24029 2476 4747 1345 4828 201 595 548 880 461 2476 4629 508 8669 817 866 553 626 2406 18162 419 448 2076 11514 2476 7896 587 448 1046 950 866 2476 7896 587 1345 24029 7918 2476 506 12730 595 860 496 383 804 190 27313 2476 11163 448 3809 548 462 835 555 434 24029 2476 27523 1434 2763 488 1182 595 24029 7918 2476 39368 448 866 6129 626 2406 2476 1359 2916 13091 918 6065 24029 1635 2476 1359 553 626 548 2406 555 800 13091 2107 553 626 2457 2406 555 13091 2476 9392 553 626 548 2406 385 553 626 2457 2406 2476 1359 7705 595 3856 6281 13091 2476 3135 2002 3984 553 626 548 2406 2129 800 16182 1946 1901 2019 3090 1789 24029 1635 2476 6551 448 1046 950 866 2476 19262 4489 2476 4629 4804 2 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   target_tokens: ['<s>', 's', 'ieve', '_=', '_[', '_1', '_]', '_*', '_(', '_1000000', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_def', '_s', 'ieve', 'Of', 'Pr', 'imes', '_(', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_global', '_s', 'ieve', '_NEW', '_', 'LINE', '_N', '_=', '_1000000', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_2', '_,', '_N', '_+', '_1', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_if', '_i', '_*', '_i', '_>', '_N', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_break', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_if', '_(', '_s', 'ieve', '_[', '_i', '_]', '_==', '_0', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_continue', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_for', '_j', '_in', '_range', '_(', '_i', '_*', '_i', '_,', '_N', '_+', '_1', '_,', '_i', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_s', 'ieve', '_[', '_j', '_]', '_=', '_0', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_D', 'ED', 'ENT', '_D', 'ED', 'ENT', '_def', '_get', 'Array', '_(', '_arr', '_,', '_N', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_global', '_s', 'ieve', '_NEW', '_', 'LINE', '_A', '_=', '_[', '_0', '_]', '_*', '_N', '_NEW', '_', 'LINE', '_v', '_=', '_[', '_]', '_NEW', '_', 'LINE', '_s', 'ieve', 'Of', 'Pr', 'imes', '_(', '_)', '_NEW', '_', 'LINE', '_for', '_i', '_in', '_range', '_(', '_2', '_,', '_int', '_(', '_1', 'e', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   target_ids: 0 201 12730 385 626 524 2406 426 400 16709 513 524 743 20786 181 4090 1551 431 12730 1307 3529 2920 400 743 545 20786 181 4090 17453 1718 3005 431 12730 20786 181 4090 591 385 16709 20786 181 4090 563 548 488 1780 400 688 2019 591 513 524 743 545 20786 181 4090 17453 1718 462 548 426 548 711 591 545 20786 181 4090 17453 1718 1127 20786 181 4090 614 1173 1718 462 400 431 12730 626 548 2406 550 461 743 545 20786 181 4090 17453 1718 2417 20786 181 4090 614 1173 1718 563 913 488 1780 400 548 426 548 2019 591 513 524 2019 548 743 545 20786 181 4090 17453 1718 431 12730 626 913 2406 385 461 20786 181 4090 614 1173 1718 614 1173 1718 614 1173 1718 1551 744 1210 400 6129 2019 591 743 545 20786 181 4090 17453 1718 3005 431 12730 20786 181 4090 553 385 626 461 2406 426 591 20786 181 4090 460 385 626 2406 20786 181 4090 431 12730 1307 3529 2920 400 743 20786 181 4090 563 548 488 1780 400 688 2019 554 400 524 187 2
03/22/2023 17:23:09 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   *** Example ***
03/22/2023 17:23:09 - INFO - __main__ -   idx: 3
03/22/2023 17:23:09 - INFO - __main__ -   source_tokens: ['<s>', 'Nth', '_natural', '_number', '_after', '_removing', '_all', '_numbers', '_consisting', '_of', '_the', '_digit', '_9', '_|', '_Function', '_to', '_find', '_N', 'th', '_number', '_in', '_base', '_9', '_;', '_Sto', 'res', '_the', '_N', 'th', '_number', '_;', '_Iterate', '_while', '_N', '_is', '_greater', '_than', '_0', '_;', '_Update', '_result', '_;', '_Divide', '_N', '_by', '_9', '_;', '_Multiply', '_p', '_by', '_10', '_;', '_Return', '_result', '_;', '_Driver', '_Code', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   source_ids: 0 37027 31175 1635 2493 14891 1345 7918 33918 595 448 12306 2737 649 4629 508 2523 591 387 1635 488 1712 2737 2476 7896 587 448 591 387 1635 2476 21519 1745 591 555 8954 2895 461 2476 3806 1046 2476 47561 591 1243 2737 2476 37891 428 1243 1865 2476 1928 1046 2476 19262 4489 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   target_tokens: ['<s>', 'def', '_find', 'Nth', 'Number', '_(', '_N', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_result', '_=', '_0', '_NEW', '_', 'LINE', '_p', '_=', '_1', '_NEW', '_', 'LINE', '_while', '_(', '_N', '_>', '_0', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_result', '_+=', '_(', '_p', '_*', '_(', '_N', '_%', '_9', '_)', '_)', '_NEW', '_', 'LINE', '_N', '_=', '_N', '_//', '_9', '_NEW', '_', 'LINE', '_p', '_=', '_p', '_*', '_10', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_return', '_result', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_if', '___', 'name', '__', '_==', "_'", '__', '__', '_main', '__', '__', "_'", '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_N', '_=', '_9', '_NEW', '_', 'LINE', '_print', '_(', '_find', 'Nth', 'Number', '_(', '_N', '_)', '_)', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   target_ids: 0 729 2523 37027 1934 400 591 743 545 20786 181 4090 17453 1718 1046 385 461 20786 181 4090 428 385 524 20786 181 4090 1745 400 591 711 461 743 545 20786 181 4090 17453 1718 1046 1054 400 428 426 400 591 726 2737 743 743 20786 181 4090 591 385 591 518 2737 20786 181 4090 428 385 428 426 1865 20786 181 4090 614 1173 1718 483 1046 20786 181 4090 614 1173 1718 462 1267 616 876 550 464 623 623 3185 623 623 464 545 20786 181 4090 17453 1718 591 385 2737 20786 181 4090 1644 400 2523 37027 1934 400 591 743 743 20786 181 4090 614 1173 1718 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   *** Example ***
03/22/2023 17:23:09 - INFO - __main__ -   idx: 4
03/22/2023 17:23:09 - INFO - __main__ -   source_tokens: ['<s>', 'Check', '_if', '_an', '_integer', '_is', '_rotation', '_of', '_another', '_given', '_integer', '_|', '_Python', '3', '_implementation', '_of', '_the', '_approach', '_;', '_Function', '_to', '_check', '_if', '_the', '_integer', '_A', '_is', '_a', '_rotation', '_of', '_the', '_integer', '_B', '_;', '_Sto', 'res', '_the', '_count', '_of', '_digits', '_in', '_A', '_;', '_Sto', 'res', '_the', '_count', '_of', '_digits', '_in', '_B', '_;', '_If', '_dig', '1', '_not', '_equal', '_to', '_dig', '2', '_;', '_Sto', 'res', '_position', '_of', '_first', '_digit', '_;', '_Sto', 'res', '_the', '_first', '_digit', '_;', '_Rotate', '_the', '_digits', '_of', '_the', '_integer', '_;', '_If', '_A', '_is', '_equal', '_to', '_B', '_;', '_If', '_A', '_is', '_equal', '_to', '_the', '_initial', '_value', '_of', '_integer', '_A', '_;', '_Driver', '_code', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   source_ids: 0 1749 462 817 3809 555 10939 595 6065 2076 3809 649 7853 137 6490 595 448 28276 2476 4629 508 1382 462 448 3809 553 555 434 10939 595 448 3809 719 2476 7896 587 448 1752 595 11134 488 553 2476 7896 587 448 1752 595 11134 488 719 2476 1359 5340 135 800 4154 508 5340 136 2476 7896 587 2763 595 1806 12306 2476 7896 587 448 1806 12306 2476 29591 448 11134 595 448 3809 2476 1359 553 555 4154 508 719 2476 1359 553 555 4154 508 448 4794 767 595 3809 553 2476 19262 1717 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
03/22/2023 17:23:09 - INFO - __main__ -   source_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
03/22/2023 17:23:09 - INFO - __main__ -   target_tokens: ['<s>', 'import', '_math', '_NEW', '_', 'LINE', '_def', '_check', '_(', '_A', '_,', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_if', '_(', '_A', '_==', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_return', '_1', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_dig', '1', '_=', '_math', '_.', '_floor', '_(', '_math', '_.', '_log', '10', '_(', '_A', '_)', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_dig', '2', '_=', '_math', '_.', '_floor', '_(', '_math', '_.', '_log', '10', '_(', '_B', '_)', '_+', '_1', '_)', '_NEW', '_', 'LINE', '_if', '_(', '_dig', '1', '_!=', '_dig', '2', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_return', '_0', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_temp', '_=', '_A', '_NEW', '_', 'LINE', '_while', '_(', '_True', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_power', '_=', '_pow', '_(', '_10', '_,', '_dig', '1', '_-', '_1', '_)', '_NEW', '_', 'LINE', '_first', 'digit', '_=', '_A', '_//', '_power', '_NEW', '_', 'LINE', '_A', '_=', '_A', '_-', '_first', 'digit', '_*', '_power', '_NEW', '_', 'LINE', '_A', '_=', '_A', '_*', '_10', '_+', '_first', 'digit', '_NEW', '_', 'LINE', '_if', '_(', '_A', '_==', '_B', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_return', '_1', '_NEW', '_', 'LINE', '_D', 'ED', 'ENT', '_if', '_(', '_A', '_==', '_temp', '_)', '_:', '_NEW', '_', 'LINE', '_IND', 'ENT', '_return', '_0', '_NEW', '_', 'LINE', '</s>']
03/22/2023 17:23:09 - INFO - __main__ -   target_ids: 0 4308 7553 20786 181 4090 1551 1382 400 553 2019 719 743 545 20786 181 4090 17453 1718 462 400 553 550 719 743 545 20786 181 4090 17453 1718 483 524 20786 181 4090 614 1173 1718 5340 135 385 7553 746 12356 400 7553 746 1592 1083 400 553 743 513 524 743 20786 181 4090 5340 136 385 7553 746 12356 400 7553 746 1592 1083 400 719 743 513 524 743 20786 181 4090 462 400 5340 135 620 5340 136 743 545 20786 181 4090 17453 1718 483 461 20786 181 4090 614 1173 1718 2803 385 553 20786 181 4090 1745 400 2998 743 545 20786 181 4090 17453 1718 7046 385 11854 400 1865 2019 5340 135 581 524 743 20786 181 4090 1806 9481 385 553 518 7046 20786 181 4090 553 385 553 581 1806 9481 426 7046 20786 181 4090 553 385 553 426 1865 513 1806 9481 20786 181 4090 462 400 553 550 719 743 545 20786 181 4090 17453 1718 483 524 20786 181 4090 614 1173 1718 462 400 553 550 2803 743 545 20786 181 4090 17453 1718 483 461 20786 181 4090 2
03/22/2023 17:23:09 - INFO - __main__ -   target_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
/home/ysnamgoong42/miniconda3/envs/xlcost/lib/python3.8/site-packages/transformers/optimization.py:306: FutureWarning: This implementation of AdamW is deprecated and will be removed in a future version. Use the PyTorch implementation torch.optim.AdamW instead, or set `no_deprecation_warning=True` to disable this warning
  warnings.warn(
03/22/2023 17:23:25 - INFO - __main__ -   ***** Running training *****
03/22/2023 17:23:25 - INFO - __main__ -     Num examples = 9263
03/22/2023 17:23:25 - INFO - __main__ -     Batch size = 16
03/22/2023 17:23:25 - INFO - __main__ -     Num epoch = 9
03/22/2023 17:23:54 - INFO - __main__ -     step 100 loss 3.9325
03/22/2023 17:24:22 - INFO - __main__ -     step 200 loss 3.1415
03/22/2023 17:24:50 - INFO - __main__ -     step 300 loss 2.7684
03/22/2023 17:25:18 - INFO - __main__ -     step 400 loss 2.5359
03/22/2023 17:25:46 - INFO - __main__ -     step 500 loss 2.3744
03/22/2023 17:26:15 - INFO - __main__ -     step 600 loss 2.2487
03/22/2023 17:26:42 - INFO - __main__ -     step 700 loss 2.1495
03/22/2023 17:27:10 - INFO - __main__ -     step 800 loss 2.0686
03/22/2023 17:27:38 - INFO - __main__ -     step 900 loss 1.9968
03/22/2023 17:28:06 - INFO - __main__ -     step 1000 loss 1.9357
03/22/2023 17:28:34 - INFO - __main__ -     step 1100 loss 1.8836
03/22/2023 17:28:50 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:28:50 - INFO - __main__ -     Num examples = 472
03/22/2023 17:28:50 - INFO - __main__ -     Batch size = 16
03/22/2023 17:28:53 - INFO - __main__ -     eval_ppl = 3.61102
03/22/2023 17:28:53 - INFO - __main__ -     global_step = 1157
03/22/2023 17:28:53 - INFO - __main__ -     train_loss = 1.857
03/22/2023 17:28:53 - INFO - __main__ -     ********************
03/22/2023 17:29:03 - INFO - __main__ -     Best ppl:3.61102
03/22/2023 17:29:03 - INFO - __main__ -     ********************
03/22/2023 17:38:34 - INFO - __main__ -     bleu-4 = 14.74 
03/22/2023 17:38:34 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:38:34 - INFO - __main__ -     ********************
03/22/2023 17:38:34 - INFO - __main__ -     Best bleu:14.74
03/22/2023 17:38:34 - INFO - __main__ -     ********************
03/22/2023 17:38:53 - INFO - __main__ -     step 1200 loss 1.3363
03/22/2023 17:39:21 - INFO - __main__ -     step 1300 loss 1.3167
03/22/2023 17:39:49 - INFO - __main__ -     step 1400 loss 1.2957
03/22/2023 17:40:17 - INFO - __main__ -     step 1500 loss 1.2775
03/22/2023 17:40:45 - INFO - __main__ -     step 1600 loss 1.2633
03/22/2023 17:41:12 - INFO - __main__ -     step 1700 loss 1.2507
03/22/2023 17:41:40 - INFO - __main__ -     step 1800 loss 1.2414
03/22/2023 17:42:08 - INFO - __main__ -     step 1900 loss 1.2321
03/22/2023 17:42:36 - INFO - __main__ -     step 2000 loss 1.2197
03/22/2023 17:43:04 - INFO - __main__ -     step 2100 loss 1.2083
03/22/2023 17:43:32 - INFO - __main__ -     step 2200 loss 1.1986
03/22/2023 17:44:00 - INFO - __main__ -     step 2300 loss 1.1889
03/22/2023 17:44:03 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:44:03 - INFO - __main__ -     Num examples = 472
03/22/2023 17:44:03 - INFO - __main__ -     Batch size = 16
03/22/2023 17:44:06 - INFO - __main__ -     eval_ppl = 2.98015
03/22/2023 17:44:06 - INFO - __main__ -     global_step = 2314
03/22/2023 17:44:06 - INFO - __main__ -     train_loss = 1.1878
03/22/2023 17:44:06 - INFO - __main__ -     ********************
03/22/2023 17:44:13 - INFO - __main__ -     Best ppl:2.98015
03/22/2023 17:44:13 - INFO - __main__ -     ********************
03/22/2023 17:52:58 - INFO - __main__ -     bleu-4 = 16.33 
03/22/2023 17:52:58 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 17:52:58 - INFO - __main__ -     ********************
03/22/2023 17:52:58 - INFO - __main__ -     Best bleu:16.33
03/22/2023 17:52:58 - INFO - __main__ -     ********************
03/22/2023 17:53:31 - INFO - __main__ -     step 2400 loss 1.092
03/22/2023 17:53:58 - INFO - __main__ -     step 2500 loss 1.0805
03/22/2023 17:54:26 - INFO - __main__ -     step 2600 loss 1.0652
03/22/2023 17:54:54 - INFO - __main__ -     step 2700 loss 1.0564
03/22/2023 17:55:22 - INFO - __main__ -     step 2800 loss 1.05
03/22/2023 17:55:50 - INFO - __main__ -     step 2900 loss 1.0437
03/22/2023 17:56:18 - INFO - __main__ -     step 3000 loss 1.0393
03/22/2023 17:56:46 - INFO - __main__ -     step 3100 loss 1.0333
03/22/2023 17:57:13 - INFO - __main__ -     step 3200 loss 1.0256
03/22/2023 17:57:41 - INFO - __main__ -     step 3300 loss 1.0196
03/22/2023 17:58:09 - INFO - __main__ -     step 3400 loss 1.0143
03/22/2023 17:58:28 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 17:58:28 - INFO - __main__ -     Num examples = 472
03/22/2023 17:58:28 - INFO - __main__ -     Batch size = 16
03/22/2023 17:58:31 - INFO - __main__ -     eval_ppl = 2.75427
03/22/2023 17:58:31 - INFO - __main__ -     global_step = 3471
03/22/2023 17:58:31 - INFO - __main__ -     train_loss = 1.0102
03/22/2023 17:58:31 - INFO - __main__ -     ********************
03/22/2023 17:58:38 - INFO - __main__ -     Best ppl:2.75427
03/22/2023 17:58:38 - INFO - __main__ -     ********************
03/22/2023 18:07:53 - INFO - __main__ -     bleu-4 = 18.42 
03/22/2023 18:07:53 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:07:53 - INFO - __main__ -     ********************
03/22/2023 18:07:53 - INFO - __main__ -     Best bleu:18.42
03/22/2023 18:07:53 - INFO - __main__ -     ********************
03/22/2023 18:08:09 - INFO - __main__ -     step 3500 loss 0.959
03/22/2023 18:08:37 - INFO - __main__ -     step 3600 loss 0.9551
03/22/2023 18:09:04 - INFO - __main__ -     step 3700 loss 0.9485
03/22/2023 18:09:32 - INFO - __main__ -     step 3800 loss 0.9394
03/22/2023 18:10:00 - INFO - __main__ -     step 3900 loss 0.9312
03/22/2023 18:10:28 - INFO - __main__ -     step 4000 loss 0.9273
03/22/2023 18:10:56 - INFO - __main__ -     step 4100 loss 0.9246
03/22/2023 18:11:23 - INFO - __main__ -     step 4200 loss 0.9225
03/22/2023 18:11:51 - INFO - __main__ -     step 4300 loss 0.918
03/22/2023 18:12:19 - INFO - __main__ -     step 4400 loss 0.9135
03/22/2023 18:12:47 - INFO - __main__ -     step 4500 loss 0.9097
03/22/2023 18:13:15 - INFO - __main__ -     step 4600 loss 0.9064
03/22/2023 18:13:22 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 18:13:22 - INFO - __main__ -     Num examples = 472
03/22/2023 18:13:22 - INFO - __main__ -     Batch size = 16
03/22/2023 18:13:25 - INFO - __main__ -     eval_ppl = 2.65968
03/22/2023 18:13:25 - INFO - __main__ -     global_step = 4628
03/22/2023 18:13:25 - INFO - __main__ -     train_loss = 0.9056
03/22/2023 18:13:25 - INFO - __main__ -     ********************
03/22/2023 18:13:32 - INFO - __main__ -     Best ppl:2.65968
03/22/2023 18:13:32 - INFO - __main__ -     ********************
03/22/2023 18:23:11 - INFO - __main__ -     bleu-4 = 20.07 
03/22/2023 18:23:11 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:23:11 - INFO - __main__ -     ********************
03/22/2023 18:23:11 - INFO - __main__ -     Best bleu:20.07
03/22/2023 18:23:11 - INFO - __main__ -     ********************
03/22/2023 18:23:37 - INFO - __main__ -     step 4700 loss 0.8802
03/22/2023 18:24:05 - INFO - __main__ -     step 4800 loss 0.8768
03/22/2023 18:24:33 - INFO - __main__ -     step 4900 loss 0.8652
03/22/2023 18:25:01 - INFO - __main__ -     step 5000 loss 0.8614
03/22/2023 18:25:29 - INFO - __main__ -     step 5100 loss 0.8589
03/22/2023 18:25:57 - INFO - __main__ -     step 5200 loss 0.8556
03/22/2023 18:26:25 - INFO - __main__ -     step 5300 loss 0.8552
03/22/2023 18:26:52 - INFO - __main__ -     step 5400 loss 0.8543
03/22/2023 18:27:20 - INFO - __main__ -     step 5500 loss 0.8508
03/22/2023 18:27:48 - INFO - __main__ -     step 5600 loss 0.8487
03/22/2023 18:28:15 - INFO - __main__ -     step 5700 loss 0.8468
03/22/2023 18:28:39 - INFO - __main__ -   
***** Running evaluation *****
03/22/2023 18:28:39 - INFO - __main__ -     Num examples = 472
03/22/2023 18:28:39 - INFO - __main__ -     Batch size = 16
03/22/2023 18:28:41 - INFO - __main__ -     eval_ppl = 2.6093
03/22/2023 18:28:41 - INFO - __main__ -     global_step = 5785
03/22/2023 18:28:41 - INFO - __main__ -     train_loss = 0.8453
03/22/2023 18:28:41 - INFO - __main__ -     ********************
03/22/2023 18:28:51 - INFO - __main__ -     Best ppl:2.6093
03/22/2023 18:28:51 - INFO - __main__ -     ********************
03/22/2023 18:38:22 - INFO - __main__ -     bleu-4 = 20.31 
03/22/2023 18:38:22 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:38:22 - INFO - __main__ -     ********************
03/22/2023 18:38:22 - INFO - __main__ -     Best bleu:20.31
03/22/2023 18:38:22 - INFO - __main__ -     ********************
03/22/2023 18:38:37 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='microsoft/unixcoder-base-nine', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='microsoft/unixcoder-base-nine', model_type='roberta', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='microsoft/unixcoder-base-nine', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 18:38:37 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 18:38:46 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 18:38:49 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:20<18:27, 20.14s/it]  4%|▎         | 2/56 [00:37<16:31, 18.36s/it]  5%|▌         | 3/56 [00:58<17:11, 19.46s/it]  7%|▋         | 4/56 [01:18<17:16, 19.93s/it]  9%|▉         | 5/56 [01:37<16:41, 19.63s/it] 11%|█         | 6/56 [01:53<15:20, 18.40s/it] 12%|█▎        | 7/56 [02:14<15:33, 19.04s/it] 14%|█▍        | 8/56 [02:36<16:04, 20.08s/it] 16%|█▌        | 9/56 [02:59<16:25, 20.97s/it] 18%|█▊        | 10/56 [03:19<15:53, 20.73s/it] 20%|█▉        | 11/56 [03:40<15:37, 20.83s/it] 21%|██▏       | 12/56 [03:58<14:40, 20.00s/it] 23%|██▎       | 13/56 [04:17<13:58, 19.50s/it] 25%|██▌       | 14/56 [04:36<13:35, 19.42s/it] 27%|██▋       | 15/56 [04:58<13:48, 20.20s/it] 29%|██▊       | 16/56 [05:17<13:18, 19.96s/it] 30%|███       | 17/56 [05:39<13:20, 20.53s/it] 32%|███▏      | 18/56 [05:56<12:18, 19.44s/it] 34%|███▍      | 19/56 [06:16<12:01, 19.49s/it] 36%|███▌      | 20/56 [06:36<11:47, 19.64s/it] 38%|███▊      | 21/56 [06:56<11:37, 19.94s/it] 39%|███▉      | 22/56 [07:11<10:20, 18.25s/it] 41%|████      | 23/56 [07:33<10:39, 19.39s/it] 43%|████▎     | 24/56 [07:53<10:33, 19.80s/it] 45%|████▍     | 25/56 [08:13<10:15, 19.85s/it] 46%|████▋     | 26/56 [08:36<10:22, 20.76s/it] 48%|████▊     | 27/56 [08:55<09:48, 20.30s/it] 50%|█████     | 28/56 [09:15<09:21, 20.05s/it] 52%|█████▏    | 29/56 [09:35<09:00, 20.00s/it] 54%|█████▎    | 30/56 [09:54<08:33, 19.76s/it] 55%|█████▌    | 31/56 [10:15<08:23, 20.15s/it] 57%|█████▋    | 32/56 [10:38<08:20, 20.87s/it] 59%|█████▉    | 33/56 [10:58<07:59, 20.83s/it] 61%|██████    | 34/56 [11:17<07:26, 20.28s/it] 62%|██████▎   | 35/56 [11:39<07:12, 20.57s/it] 64%|██████▍   | 36/56 [11:58<06:46, 20.34s/it] 66%|██████▌   | 37/56 [12:14<06:00, 18.95s/it] 68%|██████▊   | 38/56 [12:31<05:32, 18.46s/it] 70%|██████▉   | 39/56 [12:50<05:12, 18.40s/it] 71%|███████▏  | 40/56 [13:09<04:59, 18.71s/it] 73%|███████▎  | 41/56 [13:24<04:24, 17.64s/it] 75%|███████▌  | 42/56 [13:40<03:59, 17.14s/it] 77%|███████▋  | 43/56 [13:59<03:50, 17.70s/it] 79%|███████▊  | 44/56 [14:19<03:38, 18.18s/it] 80%|████████  | 45/56 [14:36<03:17, 17.93s/it] 82%|████████▏ | 46/56 [14:56<03:05, 18.57s/it] 84%|████████▍ | 47/56 [15:13<02:43, 18.21s/it] 86%|████████▌ | 48/56 [15:31<02:24, 18.10s/it] 88%|████████▊ | 49/56 [15:48<02:04, 17.85s/it] 89%|████████▉ | 50/56 [16:06<01:46, 17.81s/it] 91%|█████████ | 51/56 [16:23<01:27, 17.48s/it] 93%|█████████▎| 52/56 [16:43<01:12, 18.17s/it] 95%|█████████▍| 53/56 [17:04<00:57, 19.13s/it] 96%|█████████▋| 54/56 [17:26<00:40, 20.07s/it] 98%|█████████▊| 55/56 [17:46<00:20, 20.00s/it]100%|██████████| 56/56 [17:56<00:00, 16.88s/it]100%|██████████| 56/56 [17:56<00:00, 19.22s/it]
03/22/2023 18:56:46 - INFO - __main__ -     bleu-4 = 21.25 
03/22/2023 18:56:46 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 18:56:46 - INFO - __main__ -     ********************
tokenizer.decode(t,: def minSum ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT return mp [ arr [ i ] ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: from math import log2 NEW_LINE def bin ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def bin ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def binaryBinary ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr
tokenizer.decode(t,: from bisect import bisect_left NEW_LINE def findCount ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT v . append ( v [ i ] ) NEW_LINE v . append ( v [ i ] ) NEW_LINE v . append (
tokenizer.decode(t,: import math NEW_LINE def check ( s , s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE l = len ( s ) NEW_LINE if ( l < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DED
tokenizer.decode(t,: from math import sqrt NEW_LINE def countTriangles ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n * ( n - 1 ) * ( n - 1 ) ) * ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countTriangles ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isDivisible ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isDivisible ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def findSetBits ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 4 NEW_LINE print ( findBit ( n ) ) NEW_LINE
tokenizer.decode(t,: def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def sortArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len (
tokenizer.decode(t,: def findMin ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i ] ) : NEW_LINE INDENT j = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = i + 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE
tokenizer.decode(t,: MAX = 100 NEW_LINE def lcs ( x , y , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_
tokenizer.decode(t,: def countWays ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def countWays ( n ) : NEW_LINE INDENT return countWays ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: mod = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW
tokenizer.decode(t,: def countTriplets ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] & arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def areaArea ( a , b ) : NEW_LINE INDENT area = ( a * b ) / 2 NEW_LINE return area NEW_LINE DEDENT a = 3 NEW_LINE b = 3 NEW_LINE print ( areaArea ( a , b ) ) NEW_LINE
tokenizer.decode(t,: def minSwaps ( A , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == A [ i ] ) : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == A [ i ] ) : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_
tokenizer.decode(t,: def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ j ] ) : NEW_LINE INDENT lis [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ j ] ) : NEW_LINE INDENT lis [ i ] = lis [ i ] [ j ] NEW_
tokenizer.decode(t,: def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
tokenizer.decode(t,: def sortArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def sortArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 4 , 4 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sortArray ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def totalSquares ( n ) : NEW_LINE INDENT return ( ( 2 * n * n + 1 ) * ( 2 * n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( minimumSquares ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: from collections import defaultdict NEW_LINE def solve ( n , m , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += m [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += m [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += ans [ i ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE IND
tokenizer.decode(t,: MAX = 100 NEW_LINE dp = [ [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def findCount ( n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE
tokenizer.decode(t,: def carry ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT carry = x >> 1 NEW_LINE carry = x >> 1 NEW_LINE DEDENT return carry NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 10 NEW_LINE y = 10 NEW_LINE print ( " Sum ▁ = " , y ) NEW_LINE DEDENT
tokenizer.decode(t,: def maxXOR ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ i ] & arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findXOR ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def reverse ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( reverse ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def countStrings ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] == B [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = len ( A ) NEW_LINE B = len ( A ) NEW_LINE print ( countStrings ( A , B ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def longestSubsequence ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE countSubsequence ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def countSubarray ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def check ( a , b , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE if ( check ( a , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
tokenizer.decode(t,: def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import sys NEW_LINE MAX = 26 NEW_LINE def solve ( s , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( s [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [
tokenizer.decode(t,: MOD = 1000000007 NEW_LINE def solve ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ 0 ] == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] [ i ] = arr [ i - 1 ] + arr [ i - 1 ] [ i - 1 ] NEW_LINE DEDENT return arr [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print (
tokenizer.decode(t,: def maxSubarraySum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
tokenizer.decode(t,: def checkPalindrome ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . append ( S [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT S . append ( S [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == S [ i ] ) : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " geeks " NEW_LINE print ( S ) NEW_LINE DEDENT
tokenizer.decode(t,: from collections import defaultdict NEW_LINE def countPairs ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE print ( countStrings ( s ) ) NEW_
tokenizer.decode(t,: def count ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = " geeksforgeeksforgeeks " NEW_LINE print ( count ( str ) ) NEW_LINE
tokenizer.decode(t,: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 4 NEW_LINE print ( findArea ( r ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE findSmallest ( N ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def productOfProduct ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productProduct ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b ) == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE checkPossible ( a , b ) NEW_LINE DEDENT
tokenizer.decode(t,: def check ( x , y , y , y , y ) : NEW_LINE INDENT if ( y > y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE DEDENT
tokenizer.decode(t,: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE maxSum ( arr , N ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def countPrime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count
tokenizer.decode(t,: import math NEW_LINE def solve ( x , y , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE while ( y > y ) : NEW_LINE INDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE DEDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_
tokenizer.decode(t,: def findSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isPossible ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Yes " ) NEW_LINE DEDENT
tokenizer.decode(t,: def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE
tokenizer.decode(t,: def countPairs ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ arr [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def minOperations ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def reverse ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n % 10 NEW_LINE n = n % 10 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 10 NEW_LINE print ( reverse ( n ) ) NEW_LINE
tokenizer.decode(t,: MAX_CHAR = 26 NEW_LINE def check ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE
tokenizer.decode(t,: import math NEW_LINE def printTriangles ( n ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
tokenizer.decode(t,: def countSubstrings ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE n = len ( s ) NEW_LINE k = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE IND
tokenizer.decode(t,: def check ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def sort ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def sort ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = sorted ( b ) NEW_LINE b = sorted ( b ) NEW_LINE b = sorted ( b ) NEW_LINE print ( " Yes " ) NEW_LINE DEDENT
tokenizer.decode(t,: def minDiff ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minDiff ( arr , n ) ) NEW_LINE DEDENT
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START EVAL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: microsoft/unixcoder-base-nine
Model type: roberta
Experiment name: unixcoder_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
03/22/2023 18:56:52 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='microsoft/unixcoder-base-nine', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=200, max_steps=-1, max_target_length=200, model_name_or_path='microsoft/unixcoder-base-nine', model_type='roberta', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python', probing_case=0, seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='microsoft/unixcoder-base-nine', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/22/2023 18:56:52 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/22/2023 18:57:01 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../unixcoder_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/22/2023 18:57:03 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:20<18:42, 20.40s/it]  4%|▎         | 2/56 [00:38<17:01, 18.92s/it]  5%|▌         | 3/56 [00:58<17:16, 19.55s/it]  7%|▋         | 4/56 [01:19<17:14, 19.90s/it]  9%|▉         | 5/56 [01:38<16:43, 19.67s/it] 11%|█         | 6/56 [01:54<15:19, 18.38s/it] 12%|█▎        | 7/56 [02:14<15:25, 18.89s/it] 14%|█▍        | 8/56 [02:35<15:52, 19.85s/it] 16%|█▌        | 9/56 [02:58<16:10, 20.64s/it] 18%|█▊        | 10/56 [03:17<15:32, 20.28s/it] 20%|█▉        | 11/56 [03:38<15:18, 20.41s/it] 21%|██▏       | 12/56 [03:56<14:31, 19.81s/it] 23%|██▎       | 13/56 [04:15<13:50, 19.30s/it] 25%|██▌       | 14/56 [04:34<13:35, 19.41s/it] 27%|██▋       | 15/56 [04:56<13:47, 20.18s/it] 29%|██▊       | 16/56 [05:15<13:15, 19.89s/it] 30%|███       | 17/56 [05:37<13:13, 20.35s/it] 32%|███▏      | 18/56 [05:54<12:12, 19.27s/it] 34%|███▍      | 19/56 [06:14<11:59, 19.45s/it] 36%|███▌      | 20/56 [06:33<11:45, 19.58s/it] 38%|███▊      | 21/56 [06:54<11:38, 19.94s/it] 39%|███▉      | 22/56 [07:09<10:25, 18.38s/it] 41%|████      | 23/56 [07:31<10:46, 19.59s/it] 43%|████▎     | 24/56 [07:53<10:44, 20.13s/it] 45%|████▍     | 25/56 [08:13<10:26, 20.20s/it] 46%|████▋     | 26/56 [08:36<10:27, 20.92s/it] 48%|████▊     | 27/56 [08:55<09:51, 20.41s/it] 50%|█████     | 28/56 [09:14<09:23, 20.11s/it] 52%|█████▏    | 29/56 [09:34<08:58, 19.94s/it] 54%|█████▎    | 30/56 [09:53<08:30, 19.63s/it] 55%|█████▌    | 31/56 [10:14<08:20, 20.00s/it] 57%|█████▋    | 32/56 [10:36<08:14, 20.62s/it] 59%|█████▉    | 33/56 [10:56<07:52, 20.54s/it] 61%|██████    | 34/56 [11:15<07:20, 20.02s/it] 62%|██████▎   | 35/56 [11:36<07:05, 20.27s/it] 64%|██████▍   | 36/56 [11:55<06:39, 19.99s/it] 66%|██████▌   | 37/56 [12:10<05:52, 18.58s/it] 68%|██████▊   | 38/56 [12:27<05:24, 18.05s/it] 70%|██████▉   | 39/56 [12:45<05:05, 18.00s/it] 71%|███████▏  | 40/56 [13:04<04:50, 18.18s/it] 73%|███████▎  | 41/56 [13:18<04:14, 16.98s/it] 75%|███████▌  | 42/56 [13:33<03:50, 16.43s/it] 77%|███████▋  | 43/56 [13:51<03:40, 16.96s/it] 79%|███████▊  | 44/56 [14:10<03:30, 17.51s/it] 80%|████████  | 45/56 [14:26<03:08, 17.16s/it] 82%|████████▏ | 46/56 [14:45<02:56, 17.67s/it] 84%|████████▍ | 47/56 [15:02<02:36, 17.35s/it] 86%|████████▌ | 48/56 [15:19<02:18, 17.32s/it] 88%|████████▊ | 49/56 [15:36<02:00, 17.20s/it] 89%|████████▉ | 50/56 [15:53<01:43, 17.22s/it] 91%|█████████ | 51/56 [16:09<01:23, 16.76s/it] 93%|█████████▎| 52/56 [16:28<01:09, 17.50s/it] 95%|█████████▍| 53/56 [16:49<00:55, 18.40s/it] 96%|█████████▋| 54/56 [17:10<00:38, 19.31s/it] 98%|█████████▊| 55/56 [17:29<00:19, 19.25s/it]100%|██████████| 56/56 [17:38<00:00, 16.17s/it]100%|██████████| 56/56 [17:38<00:00, 18.90s/it]
03/22/2023 19:14:43 - INFO - __main__ -     bleu-4 = 21.25 
03/22/2023 19:14:43 - INFO - __main__ -     xMatch = 0.0 
03/22/2023 19:14:43 - INFO - __main__ -     ********************
tokenizer.decode(t,: def minSum ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT return mp [ arr [ i ] ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: from math import log2 NEW_LINE def bin ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def bin ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def binaryBinary ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr
tokenizer.decode(t,: from bisect import bisect_left NEW_LINE def findCount ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE DEDENT v . append ( v [ i ] ) NEW_LINE v . append ( v [ i ] ) NEW_LINE v . append (
tokenizer.decode(t,: import math NEW_LINE def check ( s , s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE l = len ( s ) NEW_LINE if ( l < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DED
tokenizer.decode(t,: from math import sqrt NEW_LINE def countTriangles ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n * ( n - 1 ) * ( n - 1 ) ) * ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countTriangles ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isDivisible ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isDivisible ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def findSetBits ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 4 NEW_LINE print ( findBit ( n ) ) NEW_LINE
tokenizer.decode(t,: def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def sortArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len (
tokenizer.decode(t,: def findMin ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i ] ) : NEW_LINE INDENT j = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = i + 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE
tokenizer.decode(t,: MAX = 100 NEW_LINE def lcs ( x , y , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_
tokenizer.decode(t,: def countWays ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def countWays ( n ) : NEW_LINE INDENT return countWays ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: mod = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW
tokenizer.decode(t,: def countTriplets ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] & arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def areaArea ( a , b ) : NEW_LINE INDENT area = ( a * b ) / 2 NEW_LINE return area NEW_LINE DEDENT a = 3 NEW_LINE b = 3 NEW_LINE print ( areaArea ( a , b ) ) NEW_LINE
tokenizer.decode(t,: def minSwaps ( A , N ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == A [ i ] ) : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == A [ i ] ) : NEW_LINE INDENT ans . append ( A [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_
tokenizer.decode(t,: def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ j ] ) : NEW_LINE INDENT lis [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ j ] ) : NEW_LINE INDENT lis [ i ] = lis [ i ] [ j ] NEW_
tokenizer.decode(t,: def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
tokenizer.decode(t,: def sortArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def sortArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 4 , 4 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sortArray ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def totalSquares ( n ) : NEW_LINE INDENT return ( ( 2 * n * n + 1 ) * ( 2 * n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( minimumSquares ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: from collections import defaultdict NEW_LINE def solve ( n , m , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += m [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += m [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT ans += ans [ i ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE IND
tokenizer.decode(t,: MAX = 100 NEW_LINE dp = [ [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def findCount ( n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE
tokenizer.decode(t,: def carry ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT carry = x >> 1 NEW_LINE carry = x >> 1 NEW_LINE DEDENT return carry NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 10 NEW_LINE y = 10 NEW_LINE print ( " Sum ▁ = " , y ) NEW_LINE DEDENT
tokenizer.decode(t,: def maxXOR ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ i ] & arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findXOR ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def reverse ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( reverse ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def countStrings ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] == B [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = len ( A ) NEW_LINE B = len ( A ) NEW_LINE print ( countStrings ( A , B ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def longestSubsequence ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE countSubsequence ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(t,: def countSubarray ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def check ( a , b , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE if ( check ( a , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
tokenizer.decode(t,: def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import sys NEW_LINE MAX = 26 NEW_LINE def solve ( s , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( s [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [
tokenizer.decode(t,: MOD = 1000000007 NEW_LINE def solve ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ 0 ] == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] [ i ] = arr [ i - 1 ] + arr [ i - 1 ] [ i - 1 ] NEW_LINE DEDENT return arr [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print (
tokenizer.decode(t,: def maxSubarraySum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
tokenizer.decode(t,: def checkPalindrome ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . append ( S [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT S . append ( S [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == S [ i ] ) : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] = S [ i ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " geeks " NEW_LINE print ( S ) NEW_LINE DEDENT
tokenizer.decode(t,: from collections import defaultdict NEW_LINE def countPairs ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE print ( countStrings ( s ) ) NEW_
tokenizer.decode(t,: def count ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = " geeksforgeeksforgeeks " NEW_LINE print ( count ( str ) ) NEW_LINE
tokenizer.decode(t,: def circlearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 4 NEW_LINE print ( findArea ( r ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE findSmallest ( N ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def productOfProduct ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productProduct ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b ) == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE checkPossible ( a , b ) NEW_LINE DEDENT
tokenizer.decode(t,: def check ( x , y , y , y , y ) : NEW_LINE INDENT if ( y > y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE y = 1 NEW_LINE DEDENT
tokenizer.decode(t,: def maxSum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE maxSum ( arr , N ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def countPrime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count
tokenizer.decode(t,: import math NEW_LINE def solve ( x , y , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE while ( y > y ) : NEW_LINE INDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE DEDENT y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_LINE y = y >> 1 NEW_
tokenizer.decode(t,: def findSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def isPossible ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Yes " ) NEW_LINE DEDENT
tokenizer.decode(t,: def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE
tokenizer.decode(t,: def countPairs ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ arr [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: def minOperations ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT
tokenizer.decode(t,: import math NEW_LINE def reverse ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n % 10 NEW_LINE n = n % 10 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 10 NEW_LINE print ( reverse ( n ) ) NEW_LINE
tokenizer.decode(t,: MAX_CHAR = 26 NEW_LINE def check ( str1 , str2 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE
tokenizer.decode(t,: import math NEW_LINE def printTriangles ( n ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
tokenizer.decode(t,: def countSubstrings ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE n = len ( s ) NEW_LINE k = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE IND
tokenizer.decode(t,: def check ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def sort ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def sort ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = sorted ( b ) NEW_LINE b = sorted ( b ) NEW_LINE b = sorted ( b ) NEW_LINE print ( " Yes " ) NEW_LINE DEDENT
tokenizer.decode(t,: def minDiff ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minDiff ( arr , n ) ) NEW_LINE DEDENT
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL_new.sh: line 220: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL_new.sh: line 226: --ref: command not found
